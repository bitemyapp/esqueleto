
==================== Desugar (after optimization) ====================
2018-03-24 18:20:41.844258475 UTC

Result size of Desugar (after optimization)
  = {terms: 317, types: 853, coercions: 116, joins: 0/18}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
readCannotInsert :: String
[LclIdX]
readCannotInsert
  = ghc-prim-0.5.1.1:GHC.CString.unpackCString#
      "Could not deduce (PersistStoreWrite SqlReadBackend)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
readCannotUpdate :: String
[LclIdX]
readCannotUpdate
  = ghc-prim-0.5.1.1:GHC.CString.unpackCString#
      "Could not deduce (PersistQueryWrite SqlReadBackend)"#

-- RHS size: {terms: 22, types: 48, coercions: 0, joins: 0/4}
migrateIt :: ReaderT SqlBackend DBM ()
[LclIdX]
migrateIt
  = let {
      $dMonadIO_a1Q7o :: MonadIO (R.ResourceT IO)
      [LclId]
      $dMonadIO_a1Q7o
        = Control.Monad.Trans.Resource.Internal.$fMonadIOResourceT
            @ IO Control.Monad.IO.Class.$fMonadIOIO } in
    let {
      $dMonadUnliftIO_a1Q7m :: R.MonadUnliftIO (R.ResourceT IO)
      [LclId]
      $dMonadUnliftIO_a1Q7m
        = Control.Monad.Trans.Resource.Internal.$fMonadUnliftIOResourceT
            @ IO
            unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO } in
    let {
      $dFunctor_a1Q7k :: Functor (R.ResourceT IO)
      [LclId]
      $dFunctor_a1Q7k
        = Control.Monad.Trans.Resource.Internal.$fFunctorResourceT
            @ IO GHC.Base.$fFunctorIO } in
    let {
      $dFunctor_a1Q7j :: Functor (NoLoggingT (R.ResourceT IO))
      [LclId]
      $dFunctor_a1Q7j
        = Control.Monad.Logger.$fFunctorNoLoggingT
            @ (R.ResourceT IO) $dFunctor_a1Q7k } in
    $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
      @ (ReaderT SqlBackend DBM [Data.Text.Internal.Text])
      @ (ReaderT SqlBackend DBM ())
      (void
         @ (ReaderT SqlBackend DBM)
         @ [Data.Text.Internal.Text]
         (Control.Monad.Trans.Reader.$fFunctorReaderT
            @ (NoLoggingT (R.ResourceT IO)) @ SqlBackend $dFunctor_a1Q7j))
      (runMigrationSilent
         @ DBM
         (Control.Monad.Logger.$fMonadUnliftIONoLoggingT
            @ (R.ResourceT IO) $dMonadUnliftIO_a1Q7m)
         (Control.Monad.Logger.$fMonadIONoLoggingT
            @ (R.ResourceT IO) $dMonadIO_a1Q7o)
         migrateAll)

-- RHS size: {terms: 38, types: 92, coercions: 17, joins: 0/4}
runDB
  :: forall backend a.
     IsSqlBackend backend =>
     ReaderT backend DBM a -> IO a
[LclIdX]
runDB
  = \ (@ backend_a1Q1X)
      (@ a_a1Q1Y)
      ($d(%,%)_a1Q20 :: IsSqlBackend backend_a1Q1X) ->
      let {
        $dMonad_a1Q7h :: Monad (R.ResourceT IO)
        [LclId]
        $dMonad_a1Q7h
          = Control.Monad.Trans.Resource.Internal.$fMonadResourceT
              @ IO GHC.Base.$fMonadIO } in
      let {
        $dMonadLogger_a1Q2s :: MonadLogger DBM
        [LclId]
        $dMonadLogger_a1Q2s
          = Control.Monad.Logger.$fMonadLoggerNoLoggingT
              @ (R.ResourceT IO) $dMonad_a1Q7h } in
      let {
        $dMonadUnliftIO_a1Q7e :: R.MonadUnliftIO (R.ResourceT IO)
        [LclId]
        $dMonadUnliftIO_a1Q7e
          = Control.Monad.Trans.Resource.Internal.$fMonadUnliftIOResourceT
              @ IO
              unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO } in
      let {
        $dMonadUnliftIO_a1Q2r :: R.MonadUnliftIO DBM
        [LclId]
        $dMonadUnliftIO_a1Q2r
          = Control.Monad.Logger.$fMonadUnliftIONoLoggingT
              @ (R.ResourceT IO) $dMonadUnliftIO_a1Q7e } in
      case ghc-prim-0.5.1.1:GHC.Types.HEq_sc
             @ *
             @ *
             @ (BaseBackend backend_a1Q1X)
             @ SqlBackend
             (Data.Type.Equality.$p1~
                @ *
                @ (BaseBackend backend_a1Q1X)
                @ SqlBackend
                (ghc-prim-0.5.1.1:GHC.Classes.$p2(%,%)
                   @ (IsPersistBackend backend_a1Q1X)
                   @ ((BaseBackend backend_a1Q1X :: *) ~ (SqlBackend :: *))
                   $d(%,%)_a1Q20))
      of cobox_a1Q77
      { __DEFAULT ->
      \ (action_a1Q08 :: ReaderT backend_a1Q1X DBM a_a1Q1Y) ->
        $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
          @ (R.ResourceT IO a_a1Q1Y)
          @ (IO a_a1Q1Y)
          (R.runResourceT
             @ IO
             @ a_a1Q1Y
             unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO)
          ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
             @ (NoLoggingT (R.ResourceT IO) a_a1Q1Y)
             @ (R.ResourceT IO a_a1Q1Y)
             (runNoLoggingT @ (R.ResourceT IO) @ a_a1Q1Y)
             ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                @ (backend_a1Q1X -> DBM a_a1Q1Y)
                @ (NoLoggingT (R.ResourceT IO) a_a1Q1Y)
                (withPostgresqlConn
                   @ DBM
                   @ backend_a1Q1X
                   @ a_a1Q1Y
                   $dMonadUnliftIO_a1Q2r
                   $dMonadLogger_a1Q2s
                   (($d(%,%)_a1Q20
                     `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                                <IsPersistBackend backend>_N ((~) <*>_N cobox <SqlBackend>_N)_N)_R
                             :: ((IsPersistBackend backend_a1Q1X,
                                  (BaseBackend backend_a1Q1X :: *)
                                  ~
                                  (SqlBackend :: *)) :: Constraint)
                                ~R#
                                ((IsPersistBackend backend_a1Q1X,
                                  (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)))
                    `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                               <IsPersistBackend backend>_N
                               ((~) <*>_N (Sym cobox) <SqlBackend>_N)_N)_R
                            :: ((IsPersistBackend backend_a1Q1X,
                                 (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                               ~R#
                               ((IsPersistBackend backend_a1Q1X,
                                 (BaseBackend backend_a1Q1X :: *)
                                 ~
                                 (SqlBackend :: *)) :: Constraint)))
                   (Data.String.fromString
                      @ Database.Persist.Postgresql.ConnectionString
                      Data.ByteString.Internal.$fIsStringByteString
                      (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                         "host=localhost port=5432 user=esqutest password=esqutest dbname=esqutest"#)))
                (runReaderT @ backend_a1Q1X @ * @ DBM @ a_a1Q1Y action_a1Q08)))
      }

-- RHS size: {terms: 30, types: 89, coercions: 17, joins: 0/3}
run_worker
  :: forall backend a.
     (IsSqlBackend backend, BackendCompatible SqlBackend backend) =>
     ReaderT backend DBM a -> IO a
[LclIdX]
run_worker
  = \ (@ backend_a1Q2N)
      (@ a_a1Q2O)
      ($d(%,%)_a1Q2Q :: IsSqlBackend backend_a1Q2N)
      ($dBackendCompatible_a1Q2R
         :: BackendCompatible SqlBackend backend_a1Q2N) ->
      let {
        $dMonad_a1Q7C :: Monad (R.ResourceT IO)
        [LclId]
        $dMonad_a1Q7C
          = Control.Monad.Trans.Resource.Internal.$fMonadResourceT
              @ IO GHC.Base.$fMonadIO } in
      let {
        $dMonad_a1Q7B :: Monad (NoLoggingT (R.ResourceT IO))
        [LclId]
        $dMonad_a1Q7B
          = Control.Monad.Logger.$fMonadNoLoggingT
              @ (R.ResourceT IO) $dMonad_a1Q7C } in
      let {
        $dMonad_a1Q2Y :: Monad (ReaderT backend_a1Q2N DBM)
        [LclId]
        $dMonad_a1Q2Y
          = Control.Monad.Trans.Reader.$fMonadReaderT
              @ (NoLoggingT (R.ResourceT IO)) @ backend_a1Q2N $dMonad_a1Q7B } in
      case ghc-prim-0.5.1.1:GHC.Types.HEq_sc
             @ *
             @ *
             @ (BaseBackend backend_a1Q2N)
             @ SqlBackend
             (Data.Type.Equality.$p1~
                @ *
                @ (BaseBackend backend_a1Q2N)
                @ SqlBackend
                (ghc-prim-0.5.1.1:GHC.Classes.$p2(%,%)
                   @ (IsPersistBackend backend_a1Q2N)
                   @ ((BaseBackend backend_a1Q2N :: *) ~ (SqlBackend :: *))
                   $d(%,%)_a1Q2Q))
      of cobox_a1Q7u
      { __DEFAULT ->
      \ (act_a1Q07 :: ReaderT backend_a1Q2N DBM a_a1Q2O) ->
        $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
          @ (ReaderT backend_a1Q2N DBM a_a1Q2O)
          @ (IO a_a1Q2O)
          (runDB
             @ backend_a1Q2N
             @ a_a1Q2O
             (($d(%,%)_a1Q2Q
               `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                          <IsPersistBackend backend>_N ((~) <*>_N cobox <SqlBackend>_N)_N)_R
                       :: ((IsPersistBackend backend_a1Q2N,
                            (BaseBackend backend_a1Q2N :: *)
                            ~
                            (SqlBackend :: *)) :: Constraint)
                          ~R#
                          ((IsPersistBackend backend_a1Q2N,
                            (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)))
              `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                         <IsPersistBackend backend>_N
                         ((~) <*>_N (Sym cobox) <SqlBackend>_N)_N)_R
                      :: ((IsPersistBackend backend_a1Q2N,
                           (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                         ~R#
                         ((IsPersistBackend backend_a1Q2N,
                           (BaseBackend backend_a1Q2N :: *)
                           ~
                           (SqlBackend :: *)) :: Constraint))))
          (>>
             @ (ReaderT backend_a1Q2N DBM)
             $dMonad_a1Q2Y
             @ ()
             @ a_a1Q2O
             (withReaderT
                @ *
                @ backend_a1Q2N
                @ SqlBackend
                @ DBM
                @ ()
                (projectBackend
                   @ SqlBackend @ backend_a1Q2N $dBackendCompatible_a1Q2R)
                migrateIt)
             act_a1Q07)
      }

-- RHS size: {terms: 13, types: 40, coercions: 10, joins: 0/2}
runWrite :: forall a. ReaderT SqlWriteBackend DBM a -> IO a
[LclIdX]
runWrite
  = \ (@ a_a1Q3a) ->
      let {
        $d~_a1Q7G :: (SqlBackend :: *) ~ (SqlBackend :: *)
        [LclId]
        $d~_a1Q7G
          = Data.Type.Equality.$f~kab
              @ *
              @ SqlBackend
              @ SqlBackend
              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                 @ *
                 @ *
                 @ SqlBackend
                 @ SqlBackend
                 @~ (<SqlBackend>_N
                     :: (SqlBackend :: *)
                        ghc-prim-0.5.1.1:GHC.Prim.~#
                        (SqlBackend :: *))) } in
      let {
        $d(%,%)_a1Q7E
          :: (IsPersistBackend SqlWriteBackend,
              (SqlBackend :: *) ~ (SqlBackend :: *))
        [LclId]
        $d(%,%)_a1Q7E
          = (Database.Persist.Sql.Types.Internal.$fIsPersistBackendSqlWriteBackend,
             $d~_a1Q7G) } in
      \ (act_a1Q06 :: ReaderT SqlWriteBackend DBM a_a1Q3a) ->
        run_worker
          @ SqlWriteBackend
          @ a_a1Q3a
          ($d(%,%)_a1Q7E
           `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                      <IsPersistBackend SqlWriteBackend>_N
                      ((~)
                         <*>_N
                         (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlWriteBackend[0]))
                         <SqlBackend>_N)_N)_R
                   :: ((IsPersistBackend SqlWriteBackend,
                        (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                      ~R#
                      ((IsPersistBackend SqlWriteBackend,
                        (BaseBackend SqlWriteBackend :: *)
                        ~
                        (SqlBackend :: *)) :: Constraint)))
          persistent-2.8.1:Database.Persist.Sql.Orphan.PersistStore.$fBackendCompatibleSqlBackendSqlWriteBackend
          act_a1Q06

-- RHS size: {terms: 13, types: 40, coercions: 10, joins: 0/2}
runRead :: forall a. ReaderT SqlReadBackend DBM a -> IO a
[LclIdX]
runRead
  = \ (@ a_a1Q3h) ->
      let {
        $d~_a1Q7L :: (SqlBackend :: *) ~ (SqlBackend :: *)
        [LclId]
        $d~_a1Q7L
          = Data.Type.Equality.$f~kab
              @ *
              @ SqlBackend
              @ SqlBackend
              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                 @ *
                 @ *
                 @ SqlBackend
                 @ SqlBackend
                 @~ (<SqlBackend>_N
                     :: (SqlBackend :: *)
                        ghc-prim-0.5.1.1:GHC.Prim.~#
                        (SqlBackend :: *))) } in
      let {
        $d(%,%)_a1Q7J
          :: (IsPersistBackend SqlReadBackend,
              (SqlBackend :: *) ~ (SqlBackend :: *))
        [LclId]
        $d(%,%)_a1Q7J
          = (Database.Persist.Sql.Types.Internal.$fIsPersistBackendSqlReadBackend,
             $d~_a1Q7L) } in
      \ (act_a1Q05 :: ReaderT SqlReadBackend DBM a_a1Q3h) ->
        run_worker
          @ SqlReadBackend
          @ a_a1Q3h
          ($d(%,%)_a1Q7J
           `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                      <IsPersistBackend SqlReadBackend>_N
                      ((~)
                         <*>_N
                         (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlReadBackend[0]))
                         <SqlBackend>_N)_N)_R
                   :: ((IsPersistBackend SqlReadBackend,
                        (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                      ~R#
                      ((IsPersistBackend SqlReadBackend,
                        (BaseBackend SqlReadBackend :: *)
                        ~
                        (SqlBackend :: *)) :: Constraint)))
          persistent-2.8.1:Database.Persist.Sql.Orphan.PersistStore.$fBackendCompatibleSqlBackendSqlReadBackend
          act_a1Q05

-- RHS size: {terms: 183, types: 483, coercions: 62, joins: 0/3}
testWriteFailsInRead :: Spec
[LclIdX]
testWriteFailsInRead
  = case Control.Exception.Base.typeError
           @ ('ghc-prim-0.5.1.1:GHC.Types.TupleRep '[])
           @ ((Arg ghc-prim-0.5.1.1:GHC.Types.Any :: *)
              ghc-prim-0.5.1.1:GHC.Prim.~#
              (() :: *))
           "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:51:3: error:\n\
           \    \\226\\128\\162 Couldn't match type \\226\\128\\152Arg a1\\226\\128\\153 with \\226\\128\\152()\\226\\128\\153\n\
           \      Expected type: hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM\n\
           \                       () ()\n\
           \        Actual type: SpecWith (Arg a1)\n\
           \      The type variable \\226\\128\\152a1\\226\\128\\153 is ambiguous\n\
           \    \\226\\128\\162 In a stmt of a 'do' block:\n\
           \        it \"fails when we update under a `RunRead`\"\n\
           \          $ shouldNotTypecheckWith readCannotUpdate\n\
           \              $ unsafePerformIO\n\
           \                  $ do runRead\n\
           \                         $ do let ...\n\
           \                              deepseq q (return ())\n\
           \      In the expression:\n\
           \        do it \"fails when we insert under a `RunRead`\"\n\
           \             $ do shouldNotTypecheckWith readCannotInsert\n\
           \                    $ unsafePerformIO $ runRead $ do ...\n\
           \           it \"fails when we update under a `RunRead`\"\n\
           \             $ shouldNotTypecheckWith readCannotUpdate\n\
           \                 $ unsafePerformIO $ do runRead $ do ...\n\
           \      In an equation for \\226\\128\\152testWriteFailsInRead\\226\\128\\153:\n\
           \          testWriteFailsInRead\n\
           \            = do it \"fails when we insert under a `RunRead`\"\n\
           \                   $ do shouldNotTypecheckWith readCannotInsert\n\
           \                          $ unsafePerformIO $ runRead $ ...\n\
           \                 it \"fails when we update under a `RunRead`\"\n\
           \                   $ shouldNotTypecheckWith readCannotUpdate\n\
           \                       $ unsafePerformIO $ do runRead $ ...\n\
           \(deferred type error)"#
    of cobox_a1QhZ
    { __DEFAULT ->
    case Control.Exception.Base.typeError
           @ ('ghc-prim-0.5.1.1:GHC.Types.TupleRep '[])
           @ ((Arg ghc-prim-0.5.1.1:GHC.Types.Any :: *)
              ghc-prim-0.5.1.1:GHC.Prim.~#
              (() :: *))
           "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:39:3: error:\n\
           \    \\226\\128\\162 Couldn't match type \\226\\128\\152Arg a0\\226\\128\\153 with \\226\\128\\152()\\226\\128\\153\n\
           \      Expected type: hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM\n\
           \                       () ()\n\
           \        Actual type: SpecWith (Arg a0)\n\
           \      The type variable \\226\\128\\152a0\\226\\128\\153 is ambiguous\n\
           \    \\226\\128\\162 In a stmt of a 'do' block:\n\
           \        it \"fails when we insert under a `RunRead`\"\n\
           \          $ do shouldNotTypecheckWith readCannotInsert\n\
           \                 $ unsafePerformIO $ runRead $ do void $ insert p1\n\
           \      In the expression:\n\
           \        do it \"fails when we insert under a `RunRead`\"\n\
           \             $ do shouldNotTypecheckWith readCannotInsert\n\
           \                    $ unsafePerformIO $ runRead $ do ...\n\
           \           it \"fails when we update under a `RunRead`\"\n\
           \             $ shouldNotTypecheckWith readCannotUpdate\n\
           \                 $ unsafePerformIO $ do runRead $ do ...\n\
           \      In an equation for \\226\\128\\152testWriteFailsInRead\\226\\128\\153:\n\
           \          testWriteFailsInRead\n\
           \            = do it \"fails when we insert under a `RunRead`\"\n\
           \                   $ do shouldNotTypecheckWith readCannotInsert\n\
           \                          $ unsafePerformIO $ runRead $ ...\n\
           \                 it \"fails when we update under a `RunRead`\"\n\
           \                   $ shouldNotTypecheckWith readCannotUpdate\n\
           \                       $ unsafePerformIO $ do runRead $ ...\n\
           \(deferred type error)"#
    of cobox_a1QhY
    { __DEFAULT ->
    >>
      @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM ())
      (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.$fMonadSpecM @ ())
      @ ()
      @ ()
      ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
         @ ghc-prim-0.5.1.1:GHC.Types.Any
         @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ())
         ((it
             @ ghc-prim-0.5.1.1:GHC.Types.Any
             ((GHC.Stack.Types.pushCallStack
                 (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "it"#,
                  GHC.Stack.Types.SrcLoc
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "main"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "ReadWrite.ShouldNotTypeCheck"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs"#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 39#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 3#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 39#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 46#))
                 ((GHC.Stack.Types.emptyCallStack
                   `cast` (Sym
                             (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                           :: (GHC.Stack.Types.CallStack :: *)
                              ~R#
                              ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
                  `cast` (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                            <"callStack">_N <GHC.Stack.Types.CallStack>_N
                          :: ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)
                             ~R#
                             (GHC.Stack.Types.CallStack :: *))))
              `cast` (Sym
                        (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                      :: (GHC.Stack.Types.CallStack :: *)
                         ~R#
                         ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
             (Control.Exception.Base.typeError
                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                @ (Example ghc-prim-0.5.1.1:GHC.Types.Any)
                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:39:3: error:\n\
                \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152a0\\226\\128\\153 arising from a use of \\226\\128\\152it\\226\\128\\153\n\
                \      prevents the constraint \\226\\128\\152(Example a0)\\226\\128\\153 from being solved.\n\
                \      Probable fix: use a type annotation to specify what \\226\\128\\152a0\\226\\128\\153 should be.\n\
                \      These potential instances exist:\n\
                \        instance [safe] Example Expectation\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        instance [safe] Example (a -> Expectation)\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        instance [safe] Example (a -> Bool)\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        ...plus one other\n\
                \        ...plus four instances involving out-of-scope types\n\
                \        (use -fprint-potential-instances to see them all)\n\
                \    \\226\\128\\162 In the expression: it \"fails when we insert under a `RunRead`\"\n\
                \      In a stmt of a 'do' block:\n\
                \        it \"fails when we insert under a `RunRead`\"\n\
                \          $ do shouldNotTypecheckWith readCannotInsert\n\
                \                 $ unsafePerformIO $ runRead $ do void $ insert p1\n\
                \      In the expression:\n\
                \        do it \"fails when we insert under a `RunRead`\"\n\
                \             $ do shouldNotTypecheckWith readCannotInsert\n\
                \                    $ unsafePerformIO $ runRead $ do ...\n\
                \           it \"fails when we update under a `RunRead`\"\n\
                \             $ shouldNotTypecheckWith readCannotUpdate\n\
                \                 $ unsafePerformIO $ do runRead $ do ...\n\
                \(deferred type error)"#)
             (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                "fails when we insert under a `RunRead`"#))
          `cast` (<ghc-prim-0.5.1.1:GHC.Types.Any>_R
                  -> (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                        cobox <()>_N)_R
                  :: ((ghc-prim-0.5.1.1:GHC.Types.Any
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                            (Arg ghc-prim-0.5.1.1:GHC.Types.Any) ()) :: *)
                     ~R#
                     ((ghc-prim-0.5.1.1:GHC.Types.Any
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ()) :: *)))
         ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
            @ ()
            @ ghc-prim-0.5.1.1:GHC.Types.Any
            (Control.Exception.Base.typeError
               @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
               @ (String -> () -> ghc-prim-0.5.1.1:GHC.Types.Any)
               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:40:5: error:\n\
               \    \\226\\128\\162 Variable not in scope:\n\
               \        shouldNotTypecheckWith :: String -> () -> a0\n\
               \    \\226\\128\\162 Perhaps you meant \\226\\128\\152shouldNotTypecheck\\226\\128\\153 (imported from Test.ShouldNotTypecheck)\n\
               \(deferred type error)"#
               readCannotInsert)
            ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
               @ (IO ())
               @ ()
               (unsafePerformIO @ ())
               ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                  @ (ReaderT SqlReadBackend DBM ())
                  @ (IO ())
                  (runRead @ ())
                  ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                     @ (ReaderT SqlReadBackend DBM (Key Person))
                     @ (ReaderT SqlReadBackend DBM ())
                     (void
                        @ (ReaderT SqlReadBackend DBM)
                        @ (Key Person)
                        (Control.Monad.Trans.Reader.$fFunctorReaderT
                           @ (NoLoggingT (R.ResourceT IO))
                           @ SqlReadBackend
                           (Control.Monad.Logger.$fFunctorNoLoggingT
                              @ (R.ResourceT IO)
                              (Control.Monad.Trans.Resource.Internal.$fFunctorResourceT
                                 @ IO GHC.Base.$fFunctorIO))))
                     (insert
                        @ SqlReadBackend
                        (Control.Exception.Base.typeError
                           @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                           @ (PersistStoreWrite SqlReadBackend)
                           "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:41:14: error:\n\
                           \    \\226\\128\\162 No instance for (PersistStoreWrite SqlReadBackend)\n\
                           \        arising from a use of \\226\\128\\152insert\\226\\128\\153\n\
                           \    \\226\\128\\162 In the second argument of \\226\\128\\152($)\\226\\128\\153, namely \\226\\128\\152insert p1\\226\\128\\153\n\
                           \      In a stmt of a 'do' block: void $ insert p1\n\
                           \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely \\226\\128\\152do void $ insert p1\\226\\128\\153\n\
                           \(deferred type error)"#)
                        @ DBM
                        @ Person
                        (Control.Monad.Logger.$fMonadIONoLoggingT
                           @ (R.ResourceT IO)
                           (Control.Monad.Trans.Resource.Internal.$fMonadIOResourceT
                              @ IO Control.Monad.IO.Class.$fMonadIOIO))
                        ((Common.Test.$fPersistEntityPerson,
                          Data.Type.Equality.$f~kab
                            @ *
                            @ SqlBackend
                            @ SqlBackend
                            (ghc-prim-0.5.1.1:GHC.Types.Eq#
                               @ *
                               @ *
                               @ SqlBackend
                               @ SqlBackend
                               @~ (<SqlBackend>_N
                                   :: (SqlBackend :: *)
                                      ghc-prim-0.5.1.1:GHC.Prim.~#
                                      (SqlBackend :: *))))
                         `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                                    <PersistEntity Person>_N
                                    ((~)
                                       <*>_N
                                       (Sym (Common.Test.D:R:PersistEntityBackendPerson[0]))
                                       (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlReadBackend[0])))_N)_R
                                 :: ((PersistEntity Person,
                                      (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                                    ~R#
                                    ((PersistEntity Person,
                                      (PersistEntityBackend Person :: *)
                                      ~
                                      (BaseBackend SqlReadBackend :: *)) :: Constraint)))
                        p1))))))
      ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
         @ ghc-prim-0.5.1.1:GHC.Types.Any
         @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ())
         ((it
             @ ghc-prim-0.5.1.1:GHC.Types.Any
             ((GHC.Stack.Types.pushCallStack
                 (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "it"#,
                  GHC.Stack.Types.SrcLoc
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "main"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "ReadWrite.ShouldNotTypeCheck"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs"#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 51#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 3#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 51#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 46#))
                 ((GHC.Stack.Types.emptyCallStack
                   `cast` (Sym
                             (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                           :: (GHC.Stack.Types.CallStack :: *)
                              ~R#
                              ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
                  `cast` (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                            <"callStack">_N <GHC.Stack.Types.CallStack>_N
                          :: ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)
                             ~R#
                             (GHC.Stack.Types.CallStack :: *))))
              `cast` (Sym
                        (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                      :: (GHC.Stack.Types.CallStack :: *)
                         ~R#
                         ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
             (Control.Exception.Base.typeError
                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                @ (Example ghc-prim-0.5.1.1:GHC.Types.Any)
                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:51:3: error:\n\
                \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152a1\\226\\128\\153 arising from a use of \\226\\128\\152it\\226\\128\\153\n\
                \      prevents the constraint \\226\\128\\152(Example a1)\\226\\128\\153 from being solved.\n\
                \      Probable fix: use a type annotation to specify what \\226\\128\\152a1\\226\\128\\153 should be.\n\
                \      These potential instances exist:\n\
                \        instance [safe] Example Expectation\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        instance [safe] Example (a -> Expectation)\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        instance [safe] Example (a -> Bool)\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        ...plus one other\n\
                \        ...plus four instances involving out-of-scope types\n\
                \        (use -fprint-potential-instances to see them all)\n\
                \    \\226\\128\\162 In the expression: it \"fails when we update under a `RunRead`\"\n\
                \      In a stmt of a 'do' block:\n\
                \        it \"fails when we update under a `RunRead`\"\n\
                \          $ shouldNotTypecheckWith readCannotUpdate\n\
                \              $ unsafePerformIO\n\
                \                  $ do runRead\n\
                \                         $ do let ...\n\
                \                              deepseq q (return ())\n\
                \      In the expression:\n\
                \        do it \"fails when we insert under a `RunRead`\"\n\
                \             $ do shouldNotTypecheckWith readCannotInsert\n\
                \                    $ unsafePerformIO $ runRead $ do ...\n\
                \           it \"fails when we update under a `RunRead`\"\n\
                \             $ shouldNotTypecheckWith readCannotUpdate\n\
                \                 $ unsafePerformIO $ do runRead $ do ...\n\
                \(deferred type error)"#)
             (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                "fails when we update under a `RunRead`"#))
          `cast` (<ghc-prim-0.5.1.1:GHC.Types.Any>_R
                  -> (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                        cobox <()>_N)_R
                  :: ((ghc-prim-0.5.1.1:GHC.Types.Any
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                            (Arg ghc-prim-0.5.1.1:GHC.Types.Any) ()) :: *)
                     ~R#
                     ((ghc-prim-0.5.1.1:GHC.Types.Any
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ()) :: *)))
         ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
            @ ()
            @ ghc-prim-0.5.1.1:GHC.Types.Any
            (Control.Exception.Base.typeError
               @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
               @ (String -> () -> ghc-prim-0.5.1.1:GHC.Types.Any)
               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:52:5: error:\n\
               \    \\226\\128\\162 Variable not in scope:\n\
               \        shouldNotTypecheckWith :: String -> () -> a1\n\
               \    \\226\\128\\162 Perhaps you meant \\226\\128\\152shouldNotTypecheck\\226\\128\\153 (imported from Test.ShouldNotTypecheck)\n\
               \(deferred type error)"#
               readCannotUpdate)
            ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
               @ (IO ())
               @ ()
               (unsafePerformIO @ ())
               ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                  @ (ReaderT SqlReadBackend DBM ())
                  @ (IO ())
                  (runRead @ ())
                  (deepseq
                     @ (ReaderT
                          ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ())
                     @ (ReaderT SqlReadBackend DBM ())
                     (Control.Exception.Base.typeError
                        @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                        @ (NFData
                             (ReaderT
                                ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ()))
                        "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:60:9: error:\n\
                        \    \\226\\128\\162 No instance for (NFData (ReaderT backend0 m0 ()))\n\
                        \        arising from a use of \\226\\128\\152deepseq\\226\\128\\153\n\
                        \    \\226\\128\\162 In a stmt of a 'do' block: deepseq q (return ())\n\
                        \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                        \        \\226\\128\\152do let q = update $ ...\n\
                        \            deepseq q (return ())\\226\\128\\153\n\
                        \      In a stmt of a 'do' block:\n\
                        \        runRead\n\
                        \          $ do let q = update $ ...\n\
                        \               deepseq q (return ())\n\
                        \(deferred type error)"#)
                     (let {
                        $dBackendCompatible_a1Q61
                          :: BackendCompatible SqlBackend ghc-prim-0.5.1.1:GHC.Types.Any
                        [LclId]
                        $dBackendCompatible_a1Q61
                          = Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (BackendCompatible SqlBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"# } in
                      case Control.Exception.Base.typeError
                             @ ('ghc-prim-0.5.1.1:GHC.Types.TupleRep '[])
                             @ ((BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any :: *)
                                ghc-prim-0.5.1.1:GHC.Prim.~#
                                (SqlBackend :: *))
                             "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                             \    \\226\\128\\162 Couldn't match type \\226\\128\\152BaseBackend backend0\\226\\128\\153 with \\226\\128\\152SqlBackend\\226\\128\\153\n\
                             \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                             \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                             \    \\226\\128\\162 In the expression:\n\
                             \        update\n\
                             \          $ \\ person\n\
                             \              -> do set person [...]\n\
                             \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                             \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                             \          q = update\n\
                             \                $ \\ person\n\
                             \                    -> do set person ...\n\
                             \                          ....\n\
                             \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                             \        \\226\\128\\152do let q = update $ ...\n\
                             \            deepseq q (return ())\\226\\128\\153\n\
                             \    \\226\\128\\162 Relevant bindings include\n\
                             \        q :: ReaderT backend0 m0 ()\n\
                             \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                             \(deferred type error)"#
                      of cobox_a1Qi0
                      { __DEFAULT ->
                      let {
                        $d~_a1Q5x :: (Key Person :: *) ~ (Key Person :: *)
                        [LclId]
                        $d~_a1Q5x
                          = Data.Type.Equality.$f~kab
                              @ *
                              @ (Key Person)
                              @ (Key Person)
                              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                 @ *
                                 @ *
                                 @ (Key Person)
                                 @ (Key Person)
                                 @~ (<Key Person>_N
                                     :: (Key Person :: *)
                                        ghc-prim-0.5.1.1:GHC.Prim.~#
                                        (Key Person :: *))) } in
                      let {
                        $d~_a1Q55 :: ([Char] :: *) ~ (String :: *)
                        [LclId]
                        $d~_a1Q55
                          = Data.Type.Equality.$f~kab
                              @ *
                              @ [Char]
                              @ [Char]
                              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                 @ *
                                 @ *
                                 @ [Char]
                                 @ [Char]
                                 @~ (<[Char]>_N
                                     :: ([Char] :: *)
                                        ghc-prim-0.5.1.1:GHC.Prim.~#
                                        ([Char] :: *))) } in
                      $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                        @ (SqlExpr (Entity Person) -> SqlQuery ())
                        @ (ReaderT
                             ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ())
                        (update
                           @ Person
                           @ ghc-prim-0.5.1.1:GHC.Types.Any
                           @ ghc-prim-0.5.1.1:GHC.Types.Any
                           ((Data.Type.Equality.$f~kab
                               @ *
                               @ SqlBackend
                               @ (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                               (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                  @ *
                                  @ *
                                  @ SqlBackend
                                  @ (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                                  @~ (Sym cobox_a1Qi0
                                      :: (SqlBackend :: *)
                                         ghc-prim-0.5.1.1:GHC.Prim.~#
                                         (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any :: *))))
                            `cast` (((~)
                                       <*>_N
                                       (Sym (Common.Test.D:R:PersistEntityBackendPerson[0]))
                                       <BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any>_N)_R
                                    :: ((SqlBackend :: *)
                                        ~
                                        (BaseBackend
                                           ghc-prim-0.5.1.1:GHC.Types.Any :: *) :: Constraint)
                                       ~R#
                                       ((PersistEntityBackend Person :: *)
                                        ~
                                        (BaseBackend
                                           ghc-prim-0.5.1.1:GHC.Types.Any :: *) :: Constraint)))
                           Common.Test.$fPersistEntityPerson
                           (($dBackendCompatible_a1Q61,
                             Control.Exception.Base.typeError
                               @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                               @ (PersistQueryRead ghc-prim-0.5.1.1:GHC.Types.Any)
                               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                               \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                               \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                               \                                  backend0)\\226\\128\\153 from being solved.\n\
                               \      Relevant bindings include\n\
                               \        q :: ReaderT backend0 m0 ()\n\
                               \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                               \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                               \      These potential instances exist:\n\
                               \        instance PersistQueryWrite SqlBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \        instance PersistQueryWrite SqlWriteBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \    \\226\\128\\162 In the expression:\n\
                               \        update\n\
                               \          $ \\ person\n\
                               \              -> do set person [...]\n\
                               \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                               \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                               \          q = update\n\
                               \                $ \\ person\n\
                               \                    -> do set person ...\n\
                               \                          ....\n\
                               \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                               \        \\226\\128\\152do let q = update $ ...\n\
                               \            deepseq q (return ())\\226\\128\\153\n\
                               \(deferred type error)"#,
                             Control.Exception.Base.typeError
                               @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                               @ (PersistStoreRead ghc-prim-0.5.1.1:GHC.Types.Any)
                               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                               \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                               \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                               \                                  backend0)\\226\\128\\153 from being solved.\n\
                               \      Relevant bindings include\n\
                               \        q :: ReaderT backend0 m0 ()\n\
                               \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                               \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                               \      These potential instances exist:\n\
                               \        instance PersistQueryWrite SqlBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \        instance PersistQueryWrite SqlWriteBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \    \\226\\128\\162 In the expression:\n\
                               \        update\n\
                               \          $ \\ person\n\
                               \              -> do set person [...]\n\
                               \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                               \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                               \          q = update\n\
                               \                $ \\ person\n\
                               \                    -> do set person ...\n\
                               \                          ....\n\
                               \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                               \        \\226\\128\\152do let q = update $ ...\n\
                               \            deepseq q (return ())\\226\\128\\153\n\
                               \(deferred type error)"#,
                             Control.Exception.Base.typeError
                               @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                               @ (PersistUniqueRead ghc-prim-0.5.1.1:GHC.Types.Any)
                               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                               \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                               \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                               \                                  backend0)\\226\\128\\153 from being solved.\n\
                               \      Relevant bindings include\n\
                               \        q :: ReaderT backend0 m0 ()\n\
                               \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                               \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                               \      These potential instances exist:\n\
                               \        instance PersistQueryWrite SqlBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \        instance PersistQueryWrite SqlWriteBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \    \\226\\128\\162 In the expression:\n\
                               \        update\n\
                               \          $ \\ person\n\
                               \              -> do set person [...]\n\
                               \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                               \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                               \          q = update\n\
                               \                $ \\ person\n\
                               \                    -> do set person ...\n\
                               \                          ....\n\
                               \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                               \        \\226\\128\\152do let q = update $ ...\n\
                               \            deepseq q (return ())\\226\\128\\153\n\
                               \(deferred type error)"#),
                            Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (PersistQueryWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#,
                            Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (PersistStoreWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#,
                            Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (PersistUniqueWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#)
                           $dBackendCompatible_a1Q61
                           (Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (BackendCompatible
                                   SqlBackend (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any))
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#)
                           Common.Test.$fPersistEntityPerson
                           (Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (MonadIO ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:57:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#))
                        (\ (person_a1Q04 :: SqlExpr (Entity Person)) ->
                           >>
                             @ SqlQuery
                             Database.Esqueleto.Internal.Sql.$fMonadSqlQuery
                             @ ()
                             @ ()
                             (set
                                @ SqlQuery
                                @ SqlExpr
                                @ SqlBackend
                                Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                @ Person
                                Common.Test.$fPersistEntityPerson
                                person_a1Q04
                                (ghc-prim-0.5.1.1:GHC.Types.:
                                   @ (SqlExpr (Database.Esqueleto.Internal.Language.Update Person))
                                   (=.
                                      @ SqlQuery
                                      @ SqlExpr
                                      @ SqlBackend
                                      Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                      @ Person
                                      @ [Char]
                                      Common.Test.$fPersistEntityPerson
                                      persistent-2.8.1:Database.Persist.Class.PersistField.$fPersistField[]0
                                      (Common.Test.$WPersonName @ [Char] $d~_a1Q55)
                                      (val
                                         @ SqlQuery
                                         @ SqlExpr
                                         @ SqlBackend
                                         Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                         @ [Char]
                                         persistent-2.8.1:Database.Persist.Class.PersistField.$fPersistField[]0
                                         (ghc-prim-0.5.1.1:GHC.CString.unpackCStringUtf8#
                                            "Jo\\195\\163o"#)))
                                   (ghc-prim-0.5.1.1:GHC.Types.[]
                                      @ (SqlExpr
                                           (Database.Esqueleto.Internal.Language.Update Person)))))
                             (where_
                                @ SqlQuery
                                @ SqlExpr
                                @ SqlBackend
                                Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                (==.
                                   @ SqlQuery
                                   @ SqlExpr
                                   @ SqlBackend
                                   Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                   @ (Key Person)
                                   Common.Test.$fPersistFieldKey12
                                   (^.
                                      @ SqlQuery
                                      @ SqlExpr
                                      @ SqlBackend
                                      Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                      @ Person
                                      @ (Key Person)
                                      Common.Test.$fPersistEntityPerson
                                      Common.Test.$fPersistFieldKey12
                                      person_a1Q04
                                      (Common.Test.$WPersonId @ (Key Person) $d~_a1Q5x))
                                   (val
                                      @ SqlQuery
                                      @ SqlExpr
                                      @ SqlBackend
                                      Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                      @ (Key Person)
                                      Common.Test.$fPersistFieldKey12
                                      (toSqlKey
                                         @ Person
                                         Common.Test.$fToBackendKeySqlBackendPerson
                                         (fromInteger @ GHC.Int.Int64 GHC.Int.$fNumInt64 1))))))
                      })
                     (return
                        @ (ReaderT SqlReadBackend DBM)
                        (Control.Monad.Trans.Reader.$fMonadReaderT
                           @ (NoLoggingT (R.ResourceT IO))
                           @ SqlReadBackend
                           (Control.Monad.Logger.$fMonadNoLoggingT
                              @ (R.ResourceT IO)
                              (Control.Monad.Trans.Resource.Internal.$fMonadResourceT
                                 @ IO GHC.Base.$fMonadIO)))
                        @ ()
                        ghc-prim-0.5.1.1:GHC.Tuple.()))))))
    }
    }

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
ReadWrite.ShouldNotTypeCheck.$trModule
  :: ghc-prim-0.5.1.1:GHC.Types.Module
[LclIdX]
ReadWrite.ShouldNotTypeCheck.$trModule
  = ghc-prim-0.5.1.1:GHC.Types.Module
      (ghc-prim-0.5.1.1:GHC.Types.TrNameS "main"#)
      (ghc-prim-0.5.1.1:GHC.Types.TrNameS
         "ReadWrite.ShouldNotTypeCheck"#)



==================== Desugar (after optimization) ====================
2018-03-24 18:21:06.393246004 UTC

Result size of Desugar (after optimization)
  = {terms: 323, types: 865, coercions: 116, joins: 0/19}

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/1}
shouldNotTypecheckWith :: forall p t. p -> t
[LclIdX]
shouldNotTypecheckWith
  = \ (@ p_a1Rsg) (@ t_a1Rsc) ->
      let {
        ShouldNotTypecheck_a1Rsd :: t_a1Rsc
        [LclId]
        ShouldNotTypecheck_a1Rsd
          = Control.Exception.Base.typeError
              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
              @ t_a1Rsc
              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:29:28: error:\n\
              \    \\226\\128\\162 Data constructor not in scope: ShouldNotTypecheck\n\
              \    \\226\\128\\162 Perhaps you meant one of these:\n\
              \        variable \\226\\128\\152shouldNotTypecheck\\226\\128\\153 (imported from Test.ShouldNotTypecheck),\n\
              \        variable \\226\\128\\152shouldNotTypecheckWith\\226\\128\\153 (line 29)\n\
              \(deferred type error)"# } in
      \ _ [Occ=Dead] -> ShouldNotTypecheck_a1Rsd

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
readCannotInsert :: String
[LclIdX]
readCannotInsert
  = ghc-prim-0.5.1.1:GHC.CString.unpackCString#
      "Could not deduce (PersistStoreWrite SqlReadBackend)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
readCannotUpdate :: String
[LclIdX]
readCannotUpdate
  = ghc-prim-0.5.1.1:GHC.CString.unpackCString#
      "Could not deduce (PersistQueryWrite SqlReadBackend)"#

-- RHS size: {terms: 22, types: 48, coercions: 0, joins: 0/4}
migrateIt :: ReaderT SqlBackend DBM ()
[LclIdX]
migrateIt
  = let {
      $dMonadIO_a1Rvt :: MonadIO (R.ResourceT IO)
      [LclId]
      $dMonadIO_a1Rvt
        = Control.Monad.Trans.Resource.Internal.$fMonadIOResourceT
            @ IO Control.Monad.IO.Class.$fMonadIOIO } in
    let {
      $dMonadUnliftIO_a1Rvr :: R.MonadUnliftIO (R.ResourceT IO)
      [LclId]
      $dMonadUnliftIO_a1Rvr
        = Control.Monad.Trans.Resource.Internal.$fMonadUnliftIOResourceT
            @ IO
            unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO } in
    let {
      $dFunctor_a1Rvp :: Functor (R.ResourceT IO)
      [LclId]
      $dFunctor_a1Rvp
        = Control.Monad.Trans.Resource.Internal.$fFunctorResourceT
            @ IO GHC.Base.$fFunctorIO } in
    let {
      $dFunctor_a1Rvo :: Functor (NoLoggingT (R.ResourceT IO))
      [LclId]
      $dFunctor_a1Rvo
        = Control.Monad.Logger.$fFunctorNoLoggingT
            @ (R.ResourceT IO) $dFunctor_a1Rvp } in
    $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
      @ (ReaderT SqlBackend DBM [Data.Text.Internal.Text])
      @ (ReaderT SqlBackend DBM ())
      (void
         @ (ReaderT SqlBackend DBM)
         @ [Data.Text.Internal.Text]
         (Control.Monad.Trans.Reader.$fFunctorReaderT
            @ (NoLoggingT (R.ResourceT IO)) @ SqlBackend $dFunctor_a1Rvo))
      (runMigrationSilent
         @ DBM
         (Control.Monad.Logger.$fMonadUnliftIONoLoggingT
            @ (R.ResourceT IO) $dMonadUnliftIO_a1Rvr)
         (Control.Monad.Logger.$fMonadIONoLoggingT
            @ (R.ResourceT IO) $dMonadIO_a1Rvt)
         migrateAll)

-- RHS size: {terms: 38, types: 92, coercions: 17, joins: 0/4}
runDB
  :: forall backend a.
     IsSqlBackend backend =>
     ReaderT backend DBM a -> IO a
[LclIdX]
runDB
  = \ (@ backend_a1RqT)
      (@ a_a1RqU)
      ($d(%,%)_a1RqW :: IsSqlBackend backend_a1RqT) ->
      let {
        $dMonad_a1Rvm :: Monad (R.ResourceT IO)
        [LclId]
        $dMonad_a1Rvm
          = Control.Monad.Trans.Resource.Internal.$fMonadResourceT
              @ IO GHC.Base.$fMonadIO } in
      let {
        $dMonadLogger_a1Rrb :: MonadLogger DBM
        [LclId]
        $dMonadLogger_a1Rrb
          = Control.Monad.Logger.$fMonadLoggerNoLoggingT
              @ (R.ResourceT IO) $dMonad_a1Rvm } in
      let {
        $dMonadUnliftIO_a1Rvl :: R.MonadUnliftIO (R.ResourceT IO)
        [LclId]
        $dMonadUnliftIO_a1Rvl
          = Control.Monad.Trans.Resource.Internal.$fMonadUnliftIOResourceT
              @ IO
              unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO } in
      let {
        $dMonadUnliftIO_a1Rra :: R.MonadUnliftIO DBM
        [LclId]
        $dMonadUnliftIO_a1Rra
          = Control.Monad.Logger.$fMonadUnliftIONoLoggingT
              @ (R.ResourceT IO) $dMonadUnliftIO_a1Rvl } in
      case ghc-prim-0.5.1.1:GHC.Types.HEq_sc
             @ *
             @ *
             @ (BaseBackend backend_a1RqT)
             @ SqlBackend
             (Data.Type.Equality.$p1~
                @ *
                @ (BaseBackend backend_a1RqT)
                @ SqlBackend
                (ghc-prim-0.5.1.1:GHC.Classes.$p2(%,%)
                   @ (IsPersistBackend backend_a1RqT)
                   @ ((BaseBackend backend_a1RqT :: *) ~ (SqlBackend :: *))
                   $d(%,%)_a1RqW))
      of cobox_a1Rve
      { __DEFAULT ->
      \ (action_a1Rp4 :: ReaderT backend_a1RqT DBM a_a1RqU) ->
        $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
          @ (R.ResourceT IO a_a1RqU)
          @ (IO a_a1RqU)
          (R.runResourceT
             @ IO
             @ a_a1RqU
             unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO)
          ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
             @ (NoLoggingT (R.ResourceT IO) a_a1RqU)
             @ (R.ResourceT IO a_a1RqU)
             (runNoLoggingT @ (R.ResourceT IO) @ a_a1RqU)
             ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                @ (backend_a1RqT -> DBM a_a1RqU)
                @ (NoLoggingT (R.ResourceT IO) a_a1RqU)
                (withPostgresqlConn
                   @ DBM
                   @ backend_a1RqT
                   @ a_a1RqU
                   $dMonadUnliftIO_a1Rra
                   $dMonadLogger_a1Rrb
                   (($d(%,%)_a1RqW
                     `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                                <IsPersistBackend backend>_N ((~) <*>_N cobox <SqlBackend>_N)_N)_R
                             :: ((IsPersistBackend backend_a1RqT,
                                  (BaseBackend backend_a1RqT :: *)
                                  ~
                                  (SqlBackend :: *)) :: Constraint)
                                ~R#
                                ((IsPersistBackend backend_a1RqT,
                                  (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)))
                    `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                               <IsPersistBackend backend>_N
                               ((~) <*>_N (Sym cobox) <SqlBackend>_N)_N)_R
                            :: ((IsPersistBackend backend_a1RqT,
                                 (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                               ~R#
                               ((IsPersistBackend backend_a1RqT,
                                 (BaseBackend backend_a1RqT :: *)
                                 ~
                                 (SqlBackend :: *)) :: Constraint)))
                   (Data.String.fromString
                      @ Database.Persist.Postgresql.ConnectionString
                      Data.ByteString.Internal.$fIsStringByteString
                      (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                         "host=localhost port=5432 user=esqutest password=esqutest dbname=esqutest"#)))
                (runReaderT @ backend_a1RqT @ * @ DBM @ a_a1RqU action_a1Rp4)))
      }

-- RHS size: {terms: 30, types: 89, coercions: 17, joins: 0/3}
run_worker
  :: forall backend a.
     (IsSqlBackend backend, BackendCompatible SqlBackend backend) =>
     ReaderT backend DBM a -> IO a
[LclIdX]
run_worker
  = \ (@ backend_a1Rrv)
      (@ a_a1Rrw)
      ($d(%,%)_a1Rry :: IsSqlBackend backend_a1Rrv)
      ($dBackendCompatible_a1Rrz
         :: BackendCompatible SqlBackend backend_a1Rrv) ->
      let {
        $dMonad_a1RvH :: Monad (R.ResourceT IO)
        [LclId]
        $dMonad_a1RvH
          = Control.Monad.Trans.Resource.Internal.$fMonadResourceT
              @ IO GHC.Base.$fMonadIO } in
      let {
        $dMonad_a1RvG :: Monad (NoLoggingT (R.ResourceT IO))
        [LclId]
        $dMonad_a1RvG
          = Control.Monad.Logger.$fMonadNoLoggingT
              @ (R.ResourceT IO) $dMonad_a1RvH } in
      let {
        $dMonad_a1RrG :: Monad (ReaderT backend_a1Rrv DBM)
        [LclId]
        $dMonad_a1RrG
          = Control.Monad.Trans.Reader.$fMonadReaderT
              @ (NoLoggingT (R.ResourceT IO)) @ backend_a1Rrv $dMonad_a1RvG } in
      case ghc-prim-0.5.1.1:GHC.Types.HEq_sc
             @ *
             @ *
             @ (BaseBackend backend_a1Rrv)
             @ SqlBackend
             (Data.Type.Equality.$p1~
                @ *
                @ (BaseBackend backend_a1Rrv)
                @ SqlBackend
                (ghc-prim-0.5.1.1:GHC.Classes.$p2(%,%)
                   @ (IsPersistBackend backend_a1Rrv)
                   @ ((BaseBackend backend_a1Rrv :: *) ~ (SqlBackend :: *))
                   $d(%,%)_a1Rry))
      of cobox_a1Rvz
      { __DEFAULT ->
      \ (act_a1Rp3 :: ReaderT backend_a1Rrv DBM a_a1Rrw) ->
        $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
          @ (ReaderT backend_a1Rrv DBM a_a1Rrw)
          @ (IO a_a1Rrw)
          (runDB
             @ backend_a1Rrv
             @ a_a1Rrw
             (($d(%,%)_a1Rry
               `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                          <IsPersistBackend backend>_N ((~) <*>_N cobox <SqlBackend>_N)_N)_R
                       :: ((IsPersistBackend backend_a1Rrv,
                            (BaseBackend backend_a1Rrv :: *)
                            ~
                            (SqlBackend :: *)) :: Constraint)
                          ~R#
                          ((IsPersistBackend backend_a1Rrv,
                            (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)))
              `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                         <IsPersistBackend backend>_N
                         ((~) <*>_N (Sym cobox) <SqlBackend>_N)_N)_R
                      :: ((IsPersistBackend backend_a1Rrv,
                           (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                         ~R#
                         ((IsPersistBackend backend_a1Rrv,
                           (BaseBackend backend_a1Rrv :: *)
                           ~
                           (SqlBackend :: *)) :: Constraint))))
          (>>
             @ (ReaderT backend_a1Rrv DBM)
             $dMonad_a1RrG
             @ ()
             @ a_a1Rrw
             (withReaderT
                @ *
                @ backend_a1Rrv
                @ SqlBackend
                @ DBM
                @ ()
                (projectBackend
                   @ SqlBackend @ backend_a1Rrv $dBackendCompatible_a1Rrz)
                migrateIt)
             act_a1Rp3)
      }

-- RHS size: {terms: 13, types: 40, coercions: 10, joins: 0/2}
runWrite :: forall a. ReaderT SqlWriteBackend DBM a -> IO a
[LclIdX]
runWrite
  = \ (@ a_a1RrS) ->
      let {
        $d~_a1RvL :: (SqlBackend :: *) ~ (SqlBackend :: *)
        [LclId]
        $d~_a1RvL
          = Data.Type.Equality.$f~kab
              @ *
              @ SqlBackend
              @ SqlBackend
              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                 @ *
                 @ *
                 @ SqlBackend
                 @ SqlBackend
                 @~ (<SqlBackend>_N
                     :: (SqlBackend :: *)
                        ghc-prim-0.5.1.1:GHC.Prim.~#
                        (SqlBackend :: *))) } in
      let {
        $d(%,%)_a1RvJ
          :: (IsPersistBackend SqlWriteBackend,
              (SqlBackend :: *) ~ (SqlBackend :: *))
        [LclId]
        $d(%,%)_a1RvJ
          = (Database.Persist.Sql.Types.Internal.$fIsPersistBackendSqlWriteBackend,
             $d~_a1RvL) } in
      \ (act_a1Rp2 :: ReaderT SqlWriteBackend DBM a_a1RrS) ->
        run_worker
          @ SqlWriteBackend
          @ a_a1RrS
          ($d(%,%)_a1RvJ
           `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                      <IsPersistBackend SqlWriteBackend>_N
                      ((~)
                         <*>_N
                         (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlWriteBackend[0]))
                         <SqlBackend>_N)_N)_R
                   :: ((IsPersistBackend SqlWriteBackend,
                        (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                      ~R#
                      ((IsPersistBackend SqlWriteBackend,
                        (BaseBackend SqlWriteBackend :: *)
                        ~
                        (SqlBackend :: *)) :: Constraint)))
          persistent-2.8.1:Database.Persist.Sql.Orphan.PersistStore.$fBackendCompatibleSqlBackendSqlWriteBackend
          act_a1Rp2

-- RHS size: {terms: 13, types: 40, coercions: 10, joins: 0/2}
runRead :: forall a. ReaderT SqlReadBackend DBM a -> IO a
[LclIdX]
runRead
  = \ (@ a_a1RrZ) ->
      let {
        $d~_a1RvQ :: (SqlBackend :: *) ~ (SqlBackend :: *)
        [LclId]
        $d~_a1RvQ
          = Data.Type.Equality.$f~kab
              @ *
              @ SqlBackend
              @ SqlBackend
              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                 @ *
                 @ *
                 @ SqlBackend
                 @ SqlBackend
                 @~ (<SqlBackend>_N
                     :: (SqlBackend :: *)
                        ghc-prim-0.5.1.1:GHC.Prim.~#
                        (SqlBackend :: *))) } in
      let {
        $d(%,%)_a1RvO
          :: (IsPersistBackend SqlReadBackend,
              (SqlBackend :: *) ~ (SqlBackend :: *))
        [LclId]
        $d(%,%)_a1RvO
          = (Database.Persist.Sql.Types.Internal.$fIsPersistBackendSqlReadBackend,
             $d~_a1RvQ) } in
      \ (act_a1Rp1 :: ReaderT SqlReadBackend DBM a_a1RrZ) ->
        run_worker
          @ SqlReadBackend
          @ a_a1RrZ
          ($d(%,%)_a1RvO
           `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                      <IsPersistBackend SqlReadBackend>_N
                      ((~)
                         <*>_N
                         (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlReadBackend[0]))
                         <SqlBackend>_N)_N)_R
                   :: ((IsPersistBackend SqlReadBackend,
                        (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                      ~R#
                      ((IsPersistBackend SqlReadBackend,
                        (BaseBackend SqlReadBackend :: *)
                        ~
                        (SqlBackend :: *)) :: Constraint)))
          persistent-2.8.1:Database.Persist.Sql.Orphan.PersistStore.$fBackendCompatibleSqlBackendSqlReadBackend
          act_a1Rp1

-- RHS size: {terms: 181, types: 481, coercions: 62, joins: 0/3}
testWriteFailsInRead :: Spec
[LclIdX]
testWriteFailsInRead
  = case Control.Exception.Base.typeError
           @ ('ghc-prim-0.5.1.1:GHC.Types.TupleRep '[])
           @ ((Arg ghc-prim-0.5.1.1:GHC.Types.Any :: *)
              ghc-prim-0.5.1.1:GHC.Prim.~#
              (() :: *))
           "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:53:3: error:\n\
           \    \\226\\128\\162 Couldn't match type \\226\\128\\152Arg a1\\226\\128\\153 with \\226\\128\\152()\\226\\128\\153\n\
           \      Expected type: hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM\n\
           \                       () ()\n\
           \        Actual type: SpecWith (Arg a1)\n\
           \      The type variable \\226\\128\\152a1\\226\\128\\153 is ambiguous\n\
           \    \\226\\128\\162 In a stmt of a 'do' block:\n\
           \        it \"fails when we update under a `RunRead`\"\n\
           \          $ shouldNotTypecheckWith readCannotUpdate\n\
           \              $ unsafePerformIO\n\
           \                  $ do runRead\n\
           \                         $ do let ...\n\
           \                              deepseq q (return ())\n\
           \      In the expression:\n\
           \        do it \"fails when we insert under a `RunRead`\"\n\
           \             $ do shouldNotTypecheckWith readCannotInsert\n\
           \                    $ unsafePerformIO $ runRead $ do ...\n\
           \           it \"fails when we update under a `RunRead`\"\n\
           \             $ shouldNotTypecheckWith readCannotUpdate\n\
           \                 $ unsafePerformIO $ do runRead $ do ...\n\
           \      In an equation for \\226\\128\\152testWriteFailsInRead\\226\\128\\153:\n\
           \          testWriteFailsInRead\n\
           \            = do it \"fails when we insert under a `RunRead`\"\n\
           \                   $ do shouldNotTypecheckWith readCannotInsert\n\
           \                          $ unsafePerformIO $ runRead $ ...\n\
           \                 it \"fails when we update under a `RunRead`\"\n\
           \                   $ shouldNotTypecheckWith readCannotUpdate\n\
           \                       $ unsafePerformIO $ do runRead $ ...\n\
           \(deferred type error)"#
    of cobox_a1Rwt
    { __DEFAULT ->
    case Control.Exception.Base.typeError
           @ ('ghc-prim-0.5.1.1:GHC.Types.TupleRep '[])
           @ ((Arg ghc-prim-0.5.1.1:GHC.Types.Any :: *)
              ghc-prim-0.5.1.1:GHC.Prim.~#
              (() :: *))
           "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:41:3: error:\n\
           \    \\226\\128\\162 Couldn't match type \\226\\128\\152Arg a0\\226\\128\\153 with \\226\\128\\152()\\226\\128\\153\n\
           \      Expected type: hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM\n\
           \                       () ()\n\
           \        Actual type: SpecWith (Arg a0)\n\
           \      The type variable \\226\\128\\152a0\\226\\128\\153 is ambiguous\n\
           \    \\226\\128\\162 In a stmt of a 'do' block:\n\
           \        it \"fails when we insert under a `RunRead`\"\n\
           \          $ do shouldNotTypecheckWith readCannotInsert\n\
           \                 $ unsafePerformIO $ runRead $ do void $ insert p1\n\
           \      In the expression:\n\
           \        do it \"fails when we insert under a `RunRead`\"\n\
           \             $ do shouldNotTypecheckWith readCannotInsert\n\
           \                    $ unsafePerformIO $ runRead $ do ...\n\
           \           it \"fails when we update under a `RunRead`\"\n\
           \             $ shouldNotTypecheckWith readCannotUpdate\n\
           \                 $ unsafePerformIO $ do runRead $ do ...\n\
           \      In an equation for \\226\\128\\152testWriteFailsInRead\\226\\128\\153:\n\
           \          testWriteFailsInRead\n\
           \            = do it \"fails when we insert under a `RunRead`\"\n\
           \                   $ do shouldNotTypecheckWith readCannotInsert\n\
           \                          $ unsafePerformIO $ runRead $ ...\n\
           \                 it \"fails when we update under a `RunRead`\"\n\
           \                   $ shouldNotTypecheckWith readCannotUpdate\n\
           \                       $ unsafePerformIO $ do runRead $ ...\n\
           \(deferred type error)"#
    of cobox_a1Rws
    { __DEFAULT ->
    >>
      @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM ())
      (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.$fMonadSpecM @ ())
      @ ()
      @ ()
      ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
         @ ghc-prim-0.5.1.1:GHC.Types.Any
         @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ())
         ((it
             @ ghc-prim-0.5.1.1:GHC.Types.Any
             ((GHC.Stack.Types.pushCallStack
                 (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "it"#,
                  GHC.Stack.Types.SrcLoc
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "main"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "ReadWrite.ShouldNotTypeCheck"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs"#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 41#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 3#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 41#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 46#))
                 ((GHC.Stack.Types.emptyCallStack
                   `cast` (Sym
                             (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                           :: (GHC.Stack.Types.CallStack :: *)
                              ~R#
                              ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
                  `cast` (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                            <"callStack">_N <GHC.Stack.Types.CallStack>_N
                          :: ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)
                             ~R#
                             (GHC.Stack.Types.CallStack :: *))))
              `cast` (Sym
                        (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                      :: (GHC.Stack.Types.CallStack :: *)
                         ~R#
                         ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
             (Control.Exception.Base.typeError
                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                @ (Example ghc-prim-0.5.1.1:GHC.Types.Any)
                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:41:3: error:\n\
                \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152a0\\226\\128\\153 arising from a use of \\226\\128\\152it\\226\\128\\153\n\
                \      prevents the constraint \\226\\128\\152(Example a0)\\226\\128\\153 from being solved.\n\
                \      Probable fix: use a type annotation to specify what \\226\\128\\152a0\\226\\128\\153 should be.\n\
                \      These potential instances exist:\n\
                \        instance [safe] Example Expectation\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        instance [safe] Example (a -> Expectation)\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        instance [safe] Example (a -> Bool)\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        ...plus one other\n\
                \        ...plus four instances involving out-of-scope types\n\
                \        (use -fprint-potential-instances to see them all)\n\
                \    \\226\\128\\162 In the expression: it \"fails when we insert under a `RunRead`\"\n\
                \      In a stmt of a 'do' block:\n\
                \        it \"fails when we insert under a `RunRead`\"\n\
                \          $ do shouldNotTypecheckWith readCannotInsert\n\
                \                 $ unsafePerformIO $ runRead $ do void $ insert p1\n\
                \      In the expression:\n\
                \        do it \"fails when we insert under a `RunRead`\"\n\
                \             $ do shouldNotTypecheckWith readCannotInsert\n\
                \                    $ unsafePerformIO $ runRead $ do ...\n\
                \           it \"fails when we update under a `RunRead`\"\n\
                \             $ shouldNotTypecheckWith readCannotUpdate\n\
                \                 $ unsafePerformIO $ do runRead $ do ...\n\
                \(deferred type error)"#)
             (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                "fails when we insert under a `RunRead`"#))
          `cast` (<ghc-prim-0.5.1.1:GHC.Types.Any>_R
                  -> (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                        cobox <()>_N)_R
                  :: ((ghc-prim-0.5.1.1:GHC.Types.Any
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                            (Arg ghc-prim-0.5.1.1:GHC.Types.Any) ()) :: *)
                     ~R#
                     ((ghc-prim-0.5.1.1:GHC.Types.Any
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ()) :: *)))
         ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
            @ ()
            @ ghc-prim-0.5.1.1:GHC.Types.Any
            (shouldNotTypecheckWith
               @ String @ (() -> ghc-prim-0.5.1.1:GHC.Types.Any) readCannotInsert)
            ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
               @ (IO ())
               @ ()
               (unsafePerformIO @ ())
               ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                  @ (ReaderT SqlReadBackend DBM ())
                  @ (IO ())
                  (runRead @ ())
                  ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                     @ (ReaderT SqlReadBackend DBM (Key Person))
                     @ (ReaderT SqlReadBackend DBM ())
                     (void
                        @ (ReaderT SqlReadBackend DBM)
                        @ (Key Person)
                        (Control.Monad.Trans.Reader.$fFunctorReaderT
                           @ (NoLoggingT (R.ResourceT IO))
                           @ SqlReadBackend
                           (Control.Monad.Logger.$fFunctorNoLoggingT
                              @ (R.ResourceT IO)
                              (Control.Monad.Trans.Resource.Internal.$fFunctorResourceT
                                 @ IO GHC.Base.$fFunctorIO))))
                     (insert
                        @ SqlReadBackend
                        (Control.Exception.Base.typeError
                           @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                           @ (PersistStoreWrite SqlReadBackend)
                           "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:43:14: error:\n\
                           \    \\226\\128\\162 No instance for (PersistStoreWrite SqlReadBackend)\n\
                           \        arising from a use of \\226\\128\\152insert\\226\\128\\153\n\
                           \    \\226\\128\\162 In the second argument of \\226\\128\\152($)\\226\\128\\153, namely \\226\\128\\152insert p1\\226\\128\\153\n\
                           \      In a stmt of a 'do' block: void $ insert p1\n\
                           \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely \\226\\128\\152do void $ insert p1\\226\\128\\153\n\
                           \(deferred type error)"#)
                        @ DBM
                        @ Person
                        (Control.Monad.Logger.$fMonadIONoLoggingT
                           @ (R.ResourceT IO)
                           (Control.Monad.Trans.Resource.Internal.$fMonadIOResourceT
                              @ IO Control.Monad.IO.Class.$fMonadIOIO))
                        ((Common.Test.$fPersistEntityPerson,
                          Data.Type.Equality.$f~kab
                            @ *
                            @ SqlBackend
                            @ SqlBackend
                            (ghc-prim-0.5.1.1:GHC.Types.Eq#
                               @ *
                               @ *
                               @ SqlBackend
                               @ SqlBackend
                               @~ (<SqlBackend>_N
                                   :: (SqlBackend :: *)
                                      ghc-prim-0.5.1.1:GHC.Prim.~#
                                      (SqlBackend :: *))))
                         `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                                    <PersistEntity Person>_N
                                    ((~)
                                       <*>_N
                                       (Sym (Common.Test.D:R:PersistEntityBackendPerson[0]))
                                       (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlReadBackend[0])))_N)_R
                                 :: ((PersistEntity Person,
                                      (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                                    ~R#
                                    ((PersistEntity Person,
                                      (PersistEntityBackend Person :: *)
                                      ~
                                      (BaseBackend SqlReadBackend :: *)) :: Constraint)))
                        p1))))))
      ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
         @ ghc-prim-0.5.1.1:GHC.Types.Any
         @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ())
         ((it
             @ ghc-prim-0.5.1.1:GHC.Types.Any
             ((GHC.Stack.Types.pushCallStack
                 (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "it"#,
                  GHC.Stack.Types.SrcLoc
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "main"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "ReadWrite.ShouldNotTypeCheck"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs"#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 53#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 3#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 53#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 46#))
                 ((GHC.Stack.Types.emptyCallStack
                   `cast` (Sym
                             (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                           :: (GHC.Stack.Types.CallStack :: *)
                              ~R#
                              ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
                  `cast` (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                            <"callStack">_N <GHC.Stack.Types.CallStack>_N
                          :: ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)
                             ~R#
                             (GHC.Stack.Types.CallStack :: *))))
              `cast` (Sym
                        (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                      :: (GHC.Stack.Types.CallStack :: *)
                         ~R#
                         ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
             (Control.Exception.Base.typeError
                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                @ (Example ghc-prim-0.5.1.1:GHC.Types.Any)
                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:53:3: error:\n\
                \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152a1\\226\\128\\153 arising from a use of \\226\\128\\152it\\226\\128\\153\n\
                \      prevents the constraint \\226\\128\\152(Example a1)\\226\\128\\153 from being solved.\n\
                \      Probable fix: use a type annotation to specify what \\226\\128\\152a1\\226\\128\\153 should be.\n\
                \      These potential instances exist:\n\
                \        instance [safe] Example Expectation\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        instance [safe] Example (a -> Expectation)\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        instance [safe] Example (a -> Bool)\n\
                \          -- Defined in \\226\\128\\152hspec-core-2.4.4:Test.Hspec.Core.Example\\226\\128\\153\n\
                \        ...plus one other\n\
                \        ...plus four instances involving out-of-scope types\n\
                \        (use -fprint-potential-instances to see them all)\n\
                \    \\226\\128\\162 In the expression: it \"fails when we update under a `RunRead`\"\n\
                \      In a stmt of a 'do' block:\n\
                \        it \"fails when we update under a `RunRead`\"\n\
                \          $ shouldNotTypecheckWith readCannotUpdate\n\
                \              $ unsafePerformIO\n\
                \                  $ do runRead\n\
                \                         $ do let ...\n\
                \                              deepseq q (return ())\n\
                \      In the expression:\n\
                \        do it \"fails when we insert under a `RunRead`\"\n\
                \             $ do shouldNotTypecheckWith readCannotInsert\n\
                \                    $ unsafePerformIO $ runRead $ do ...\n\
                \           it \"fails when we update under a `RunRead`\"\n\
                \             $ shouldNotTypecheckWith readCannotUpdate\n\
                \                 $ unsafePerformIO $ do runRead $ do ...\n\
                \(deferred type error)"#)
             (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                "fails when we update under a `RunRead`"#))
          `cast` (<ghc-prim-0.5.1.1:GHC.Types.Any>_R
                  -> (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                        cobox <()>_N)_R
                  :: ((ghc-prim-0.5.1.1:GHC.Types.Any
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                            (Arg ghc-prim-0.5.1.1:GHC.Types.Any) ()) :: *)
                     ~R#
                     ((ghc-prim-0.5.1.1:GHC.Types.Any
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ()) :: *)))
         ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
            @ ()
            @ ghc-prim-0.5.1.1:GHC.Types.Any
            (shouldNotTypecheckWith
               @ String @ (() -> ghc-prim-0.5.1.1:GHC.Types.Any) readCannotUpdate)
            ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
               @ (IO ())
               @ ()
               (unsafePerformIO @ ())
               ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                  @ (ReaderT SqlReadBackend DBM ())
                  @ (IO ())
                  (runRead @ ())
                  (deepseq
                     @ (ReaderT
                          ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ())
                     @ (ReaderT SqlReadBackend DBM ())
                     (Control.Exception.Base.typeError
                        @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                        @ (NFData
                             (ReaderT
                                ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ()))
                        "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:62:9: error:\n\
                        \    \\226\\128\\162 No instance for (NFData (ReaderT backend0 m0 ()))\n\
                        \        arising from a use of \\226\\128\\152deepseq\\226\\128\\153\n\
                        \    \\226\\128\\162 In a stmt of a 'do' block: deepseq q (return ())\n\
                        \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                        \        \\226\\128\\152do let q = update $ ...\n\
                        \            deepseq q (return ())\\226\\128\\153\n\
                        \      In a stmt of a 'do' block:\n\
                        \        runRead\n\
                        \          $ do let q = update $ ...\n\
                        \               deepseq q (return ())\n\
                        \(deferred type error)"#)
                     (let {
                        $dBackendCompatible_a1RuG
                          :: BackendCompatible SqlBackend ghc-prim-0.5.1.1:GHC.Types.Any
                        [LclId]
                        $dBackendCompatible_a1RuG
                          = Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (BackendCompatible SqlBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"# } in
                      case Control.Exception.Base.typeError
                             @ ('ghc-prim-0.5.1.1:GHC.Types.TupleRep '[])
                             @ ((BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any :: *)
                                ghc-prim-0.5.1.1:GHC.Prim.~#
                                (SqlBackend :: *))
                             "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                             \    \\226\\128\\162 Couldn't match type \\226\\128\\152BaseBackend backend0\\226\\128\\153 with \\226\\128\\152SqlBackend\\226\\128\\153\n\
                             \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                             \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                             \    \\226\\128\\162 In the expression:\n\
                             \        update\n\
                             \          $ \\ person\n\
                             \              -> do set person [...]\n\
                             \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                             \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                             \          q = update\n\
                             \                $ \\ person\n\
                             \                    -> do set person ...\n\
                             \                          ....\n\
                             \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                             \        \\226\\128\\152do let q = update $ ...\n\
                             \            deepseq q (return ())\\226\\128\\153\n\
                             \    \\226\\128\\162 Relevant bindings include\n\
                             \        q :: ReaderT backend0 m0 ()\n\
                             \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                             \(deferred type error)"#
                      of cobox_a1Rwu
                      { __DEFAULT ->
                      let {
                        $d~_a1Ruc :: (Key Person :: *) ~ (Key Person :: *)
                        [LclId]
                        $d~_a1Ruc
                          = Data.Type.Equality.$f~kab
                              @ *
                              @ (Key Person)
                              @ (Key Person)
                              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                 @ *
                                 @ *
                                 @ (Key Person)
                                 @ (Key Person)
                                 @~ (<Key Person>_N
                                     :: (Key Person :: *)
                                        ghc-prim-0.5.1.1:GHC.Prim.~#
                                        (Key Person :: *))) } in
                      let {
                        $d~_a1RtK :: ([Char] :: *) ~ (String :: *)
                        [LclId]
                        $d~_a1RtK
                          = Data.Type.Equality.$f~kab
                              @ *
                              @ [Char]
                              @ [Char]
                              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                 @ *
                                 @ *
                                 @ [Char]
                                 @ [Char]
                                 @~ (<[Char]>_N
                                     :: ([Char] :: *)
                                        ghc-prim-0.5.1.1:GHC.Prim.~#
                                        ([Char] :: *))) } in
                      $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                        @ (SqlExpr (Entity Person) -> SqlQuery ())
                        @ (ReaderT
                             ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ())
                        (update
                           @ Person
                           @ ghc-prim-0.5.1.1:GHC.Types.Any
                           @ ghc-prim-0.5.1.1:GHC.Types.Any
                           ((Data.Type.Equality.$f~kab
                               @ *
                               @ SqlBackend
                               @ (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                               (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                  @ *
                                  @ *
                                  @ SqlBackend
                                  @ (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                                  @~ (Sym cobox_a1Rwu
                                      :: (SqlBackend :: *)
                                         ghc-prim-0.5.1.1:GHC.Prim.~#
                                         (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any :: *))))
                            `cast` (((~)
                                       <*>_N
                                       (Sym (Common.Test.D:R:PersistEntityBackendPerson[0]))
                                       <BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any>_N)_R
                                    :: ((SqlBackend :: *)
                                        ~
                                        (BaseBackend
                                           ghc-prim-0.5.1.1:GHC.Types.Any :: *) :: Constraint)
                                       ~R#
                                       ((PersistEntityBackend Person :: *)
                                        ~
                                        (BaseBackend
                                           ghc-prim-0.5.1.1:GHC.Types.Any :: *) :: Constraint)))
                           Common.Test.$fPersistEntityPerson
                           (($dBackendCompatible_a1RuG,
                             Control.Exception.Base.typeError
                               @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                               @ (PersistQueryRead ghc-prim-0.5.1.1:GHC.Types.Any)
                               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                               \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                               \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                               \                                  backend0)\\226\\128\\153 from being solved.\n\
                               \      Relevant bindings include\n\
                               \        q :: ReaderT backend0 m0 ()\n\
                               \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                               \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                               \      These potential instances exist:\n\
                               \        instance PersistQueryWrite SqlBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \        instance PersistQueryWrite SqlWriteBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \    \\226\\128\\162 In the expression:\n\
                               \        update\n\
                               \          $ \\ person\n\
                               \              -> do set person [...]\n\
                               \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                               \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                               \          q = update\n\
                               \                $ \\ person\n\
                               \                    -> do set person ...\n\
                               \                          ....\n\
                               \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                               \        \\226\\128\\152do let q = update $ ...\n\
                               \            deepseq q (return ())\\226\\128\\153\n\
                               \(deferred type error)"#,
                             Control.Exception.Base.typeError
                               @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                               @ (PersistStoreRead ghc-prim-0.5.1.1:GHC.Types.Any)
                               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                               \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                               \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                               \                                  backend0)\\226\\128\\153 from being solved.\n\
                               \      Relevant bindings include\n\
                               \        q :: ReaderT backend0 m0 ()\n\
                               \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                               \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                               \      These potential instances exist:\n\
                               \        instance PersistQueryWrite SqlBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \        instance PersistQueryWrite SqlWriteBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \    \\226\\128\\162 In the expression:\n\
                               \        update\n\
                               \          $ \\ person\n\
                               \              -> do set person [...]\n\
                               \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                               \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                               \          q = update\n\
                               \                $ \\ person\n\
                               \                    -> do set person ...\n\
                               \                          ....\n\
                               \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                               \        \\226\\128\\152do let q = update $ ...\n\
                               \            deepseq q (return ())\\226\\128\\153\n\
                               \(deferred type error)"#,
                             Control.Exception.Base.typeError
                               @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                               @ (PersistUniqueRead ghc-prim-0.5.1.1:GHC.Types.Any)
                               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                               \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                               \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                               \                                  backend0)\\226\\128\\153 from being solved.\n\
                               \      Relevant bindings include\n\
                               \        q :: ReaderT backend0 m0 ()\n\
                               \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                               \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                               \      These potential instances exist:\n\
                               \        instance PersistQueryWrite SqlBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \        instance PersistQueryWrite SqlWriteBackend\n\
                               \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                               \    \\226\\128\\162 In the expression:\n\
                               \        update\n\
                               \          $ \\ person\n\
                               \              -> do set person [...]\n\
                               \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                               \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                               \          q = update\n\
                               \                $ \\ person\n\
                               \                    -> do set person ...\n\
                               \                          ....\n\
                               \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                               \        \\226\\128\\152do let q = update $ ...\n\
                               \            deepseq q (return ())\\226\\128\\153\n\
                               \(deferred type error)"#),
                            Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (PersistQueryWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#,
                            Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (PersistStoreWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#,
                            Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (PersistUniqueWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#)
                           $dBackendCompatible_a1RuG
                           (Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (BackendCompatible
                                   SqlBackend (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any))
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#)
                           Common.Test.$fPersistEntityPerson
                           (Control.Exception.Base.typeError
                              @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                              @ (MonadIO ghc-prim-0.5.1.1:GHC.Types.Any)
                              "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                              \    \\226\\128\\162 Ambiguous type variable \\226\\128\\152backend0\\226\\128\\153 arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                              \      prevents the constraint \\226\\128\\152(PersistQueryWrite\n\
                              \                                  backend0)\\226\\128\\153 from being solved.\n\
                              \      Relevant bindings include\n\
                              \        q :: ReaderT backend0 m0 ()\n\
                              \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                              \      Probable fix: use a type annotation to specify what \\226\\128\\152backend0\\226\\128\\153 should be.\n\
                              \      These potential instances exist:\n\
                              \        instance PersistQueryWrite SqlBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \        instance PersistQueryWrite SqlWriteBackend\n\
                              \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                              \    \\226\\128\\162 In the expression:\n\
                              \        update\n\
                              \          $ \\ person\n\
                              \              -> do set person [...]\n\
                              \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                              \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                              \          q = update\n\
                              \                $ \\ person\n\
                              \                    -> do set person ...\n\
                              \                          ....\n\
                              \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                              \        \\226\\128\\152do let q = update $ ...\n\
                              \            deepseq q (return ())\\226\\128\\153\n\
                              \(deferred type error)"#))
                        (\ (person_a1Rp0 :: SqlExpr (Entity Person)) ->
                           >>
                             @ SqlQuery
                             Database.Esqueleto.Internal.Sql.$fMonadSqlQuery
                             @ ()
                             @ ()
                             (set
                                @ SqlQuery
                                @ SqlExpr
                                @ SqlBackend
                                Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                @ Person
                                Common.Test.$fPersistEntityPerson
                                person_a1Rp0
                                (ghc-prim-0.5.1.1:GHC.Types.:
                                   @ (SqlExpr (Database.Esqueleto.Internal.Language.Update Person))
                                   (=.
                                      @ SqlQuery
                                      @ SqlExpr
                                      @ SqlBackend
                                      Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                      @ Person
                                      @ [Char]
                                      Common.Test.$fPersistEntityPerson
                                      persistent-2.8.1:Database.Persist.Class.PersistField.$fPersistField[]0
                                      (Common.Test.$WPersonName @ [Char] $d~_a1RtK)
                                      (val
                                         @ SqlQuery
                                         @ SqlExpr
                                         @ SqlBackend
                                         Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                         @ [Char]
                                         persistent-2.8.1:Database.Persist.Class.PersistField.$fPersistField[]0
                                         (ghc-prim-0.5.1.1:GHC.CString.unpackCStringUtf8#
                                            "Jo\\195\\163o"#)))
                                   (ghc-prim-0.5.1.1:GHC.Types.[]
                                      @ (SqlExpr
                                           (Database.Esqueleto.Internal.Language.Update Person)))))
                             (where_
                                @ SqlQuery
                                @ SqlExpr
                                @ SqlBackend
                                Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                (==.
                                   @ SqlQuery
                                   @ SqlExpr
                                   @ SqlBackend
                                   Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                   @ (Key Person)
                                   Common.Test.$fPersistFieldKey12
                                   (^.
                                      @ SqlQuery
                                      @ SqlExpr
                                      @ SqlBackend
                                      Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                      @ Person
                                      @ (Key Person)
                                      Common.Test.$fPersistEntityPerson
                                      Common.Test.$fPersistFieldKey12
                                      person_a1Rp0
                                      (Common.Test.$WPersonId @ (Key Person) $d~_a1Ruc))
                                   (val
                                      @ SqlQuery
                                      @ SqlExpr
                                      @ SqlBackend
                                      Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                      @ (Key Person)
                                      Common.Test.$fPersistFieldKey12
                                      (toSqlKey
                                         @ Person
                                         Common.Test.$fToBackendKeySqlBackendPerson
                                         (fromInteger @ GHC.Int.Int64 GHC.Int.$fNumInt64 1))))))
                      })
                     (return
                        @ (ReaderT SqlReadBackend DBM)
                        (Control.Monad.Trans.Reader.$fMonadReaderT
                           @ (NoLoggingT (R.ResourceT IO))
                           @ SqlReadBackend
                           (Control.Monad.Logger.$fMonadNoLoggingT
                              @ (R.ResourceT IO)
                              (Control.Monad.Trans.Resource.Internal.$fMonadResourceT
                                 @ IO GHC.Base.$fMonadIO)))
                        @ ()
                        ghc-prim-0.5.1.1:GHC.Tuple.()))))))
    }
    }

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
ReadWrite.ShouldNotTypeCheck.$trModule
  :: ghc-prim-0.5.1.1:GHC.Types.Module
[LclIdX]
ReadWrite.ShouldNotTypeCheck.$trModule
  = ghc-prim-0.5.1.1:GHC.Types.Module
      (ghc-prim-0.5.1.1:GHC.Types.TrNameS "main"#)
      (ghc-prim-0.5.1.1:GHC.Types.TrNameS
         "ReadWrite.ShouldNotTypeCheck"#)



==================== Desugar (after optimization) ====================
2018-03-24 18:21:11.460916825 UTC

Result size of Desugar (after optimization)
  = {terms: 316, types: 819, coercions: 112, joins: 0/18}

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
shouldNotTypecheckWith
  :: forall a p.
     NFData a =>
     p
     -> ((() :: *) ~ (() :: *) => a)
     -> HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
[LclIdX]
shouldNotTypecheckWith
  = \ (@ a_a1RPl)
      (@ p_a1RPq)
      ($dNFData_a1RPu :: NFData a_a1RPl)
      _ [Occ=Dead] ->
      shouldNotTypecheck @ a_a1RPl $dNFData_a1RPu

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
readCannotInsert :: String
[LclIdX]
readCannotInsert
  = ghc-prim-0.5.1.1:GHC.CString.unpackCString#
      "Could not deduce (PersistStoreWrite SqlReadBackend)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
readCannotUpdate :: String
[LclIdX]
readCannotUpdate
  = ghc-prim-0.5.1.1:GHC.CString.unpackCString#
      "Could not deduce (PersistQueryWrite SqlReadBackend)"#

-- RHS size: {terms: 22, types: 48, coercions: 0, joins: 0/4}
migrateIt :: ReaderT SqlBackend DBM ()
[LclIdX]
migrateIt
  = let {
      $dMonadIO_a1RST :: MonadIO (R.ResourceT IO)
      [LclId]
      $dMonadIO_a1RST
        = Control.Monad.Trans.Resource.Internal.$fMonadIOResourceT
            @ IO Control.Monad.IO.Class.$fMonadIOIO } in
    let {
      $dMonadUnliftIO_a1RSR :: R.MonadUnliftIO (R.ResourceT IO)
      [LclId]
      $dMonadUnliftIO_a1RSR
        = Control.Monad.Trans.Resource.Internal.$fMonadUnliftIOResourceT
            @ IO
            unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO } in
    let {
      $dFunctor_a1RSP :: Functor (R.ResourceT IO)
      [LclId]
      $dFunctor_a1RSP
        = Control.Monad.Trans.Resource.Internal.$fFunctorResourceT
            @ IO GHC.Base.$fFunctorIO } in
    let {
      $dFunctor_a1RSO :: Functor (NoLoggingT (R.ResourceT IO))
      [LclId]
      $dFunctor_a1RSO
        = Control.Monad.Logger.$fFunctorNoLoggingT
            @ (R.ResourceT IO) $dFunctor_a1RSP } in
    $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
      @ (ReaderT SqlBackend DBM [Data.Text.Internal.Text])
      @ (ReaderT SqlBackend DBM ())
      (void
         @ (ReaderT SqlBackend DBM)
         @ [Data.Text.Internal.Text]
         (Control.Monad.Trans.Reader.$fFunctorReaderT
            @ (NoLoggingT (R.ResourceT IO)) @ SqlBackend $dFunctor_a1RSO))
      (runMigrationSilent
         @ DBM
         (Control.Monad.Logger.$fMonadUnliftIONoLoggingT
            @ (R.ResourceT IO) $dMonadUnliftIO_a1RSR)
         (Control.Monad.Logger.$fMonadIONoLoggingT
            @ (R.ResourceT IO) $dMonadIO_a1RST)
         migrateAll)

-- RHS size: {terms: 38, types: 92, coercions: 17, joins: 0/4}
runDB
  :: forall backend a.
     IsSqlBackend backend =>
     ReaderT backend DBM a -> IO a
[LclIdX]
runDB
  = \ (@ backend_a1RO2)
      (@ a_a1RO3)
      ($d(%,%)_a1RO5 :: IsSqlBackend backend_a1RO2) ->
      let {
        $dMonad_a1RSM :: Monad (R.ResourceT IO)
        [LclId]
        $dMonad_a1RSM
          = Control.Monad.Trans.Resource.Internal.$fMonadResourceT
              @ IO GHC.Base.$fMonadIO } in
      let {
        $dMonadLogger_a1ROk :: MonadLogger DBM
        [LclId]
        $dMonadLogger_a1ROk
          = Control.Monad.Logger.$fMonadLoggerNoLoggingT
              @ (R.ResourceT IO) $dMonad_a1RSM } in
      let {
        $dMonadUnliftIO_a1RSL :: R.MonadUnliftIO (R.ResourceT IO)
        [LclId]
        $dMonadUnliftIO_a1RSL
          = Control.Monad.Trans.Resource.Internal.$fMonadUnliftIOResourceT
              @ IO
              unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO } in
      let {
        $dMonadUnliftIO_a1ROj :: R.MonadUnliftIO DBM
        [LclId]
        $dMonadUnliftIO_a1ROj
          = Control.Monad.Logger.$fMonadUnliftIONoLoggingT
              @ (R.ResourceT IO) $dMonadUnliftIO_a1RSL } in
      case ghc-prim-0.5.1.1:GHC.Types.HEq_sc
             @ *
             @ *
             @ (BaseBackend backend_a1RO2)
             @ SqlBackend
             (Data.Type.Equality.$p1~
                @ *
                @ (BaseBackend backend_a1RO2)
                @ SqlBackend
                (ghc-prim-0.5.1.1:GHC.Classes.$p2(%,%)
                   @ (IsPersistBackend backend_a1RO2)
                   @ ((BaseBackend backend_a1RO2 :: *) ~ (SqlBackend :: *))
                   $d(%,%)_a1RO5))
      of cobox_a1RSE
      { __DEFAULT ->
      \ (action_a1RMd :: ReaderT backend_a1RO2 DBM a_a1RO3) ->
        $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
          @ (R.ResourceT IO a_a1RO3)
          @ (IO a_a1RO3)
          (R.runResourceT
             @ IO
             @ a_a1RO3
             unliftio-core-0.1.1.0:Control.Monad.IO.Unlift.$fMonadUnliftIOIO)
          ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
             @ (NoLoggingT (R.ResourceT IO) a_a1RO3)
             @ (R.ResourceT IO a_a1RO3)
             (runNoLoggingT @ (R.ResourceT IO) @ a_a1RO3)
             ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                @ (backend_a1RO2 -> DBM a_a1RO3)
                @ (NoLoggingT (R.ResourceT IO) a_a1RO3)
                (withPostgresqlConn
                   @ DBM
                   @ backend_a1RO2
                   @ a_a1RO3
                   $dMonadUnliftIO_a1ROj
                   $dMonadLogger_a1ROk
                   (($d(%,%)_a1RO5
                     `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                                <IsPersistBackend backend>_N ((~) <*>_N cobox <SqlBackend>_N)_N)_R
                             :: ((IsPersistBackend backend_a1RO2,
                                  (BaseBackend backend_a1RO2 :: *)
                                  ~
                                  (SqlBackend :: *)) :: Constraint)
                                ~R#
                                ((IsPersistBackend backend_a1RO2,
                                  (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)))
                    `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                               <IsPersistBackend backend>_N
                               ((~) <*>_N (Sym cobox) <SqlBackend>_N)_N)_R
                            :: ((IsPersistBackend backend_a1RO2,
                                 (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                               ~R#
                               ((IsPersistBackend backend_a1RO2,
                                 (BaseBackend backend_a1RO2 :: *)
                                 ~
                                 (SqlBackend :: *)) :: Constraint)))
                   (Data.String.fromString
                      @ Database.Persist.Postgresql.ConnectionString
                      Data.ByteString.Internal.$fIsStringByteString
                      (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                         "host=localhost port=5432 user=esqutest password=esqutest dbname=esqutest"#)))
                (runReaderT @ backend_a1RO2 @ * @ DBM @ a_a1RO3 action_a1RMd)))
      }

-- RHS size: {terms: 30, types: 89, coercions: 17, joins: 0/3}
run_worker
  :: forall backend a.
     (IsSqlBackend backend, BackendCompatible SqlBackend backend) =>
     ReaderT backend DBM a -> IO a
[LclIdX]
run_worker
  = \ (@ backend_a1ROE)
      (@ a_a1ROF)
      ($d(%,%)_a1ROH :: IsSqlBackend backend_a1ROE)
      ($dBackendCompatible_a1ROI
         :: BackendCompatible SqlBackend backend_a1ROE) ->
      let {
        $dMonad_a1RT7 :: Monad (R.ResourceT IO)
        [LclId]
        $dMonad_a1RT7
          = Control.Monad.Trans.Resource.Internal.$fMonadResourceT
              @ IO GHC.Base.$fMonadIO } in
      let {
        $dMonad_a1RT6 :: Monad (NoLoggingT (R.ResourceT IO))
        [LclId]
        $dMonad_a1RT6
          = Control.Monad.Logger.$fMonadNoLoggingT
              @ (R.ResourceT IO) $dMonad_a1RT7 } in
      let {
        $dMonad_a1ROP :: Monad (ReaderT backend_a1ROE DBM)
        [LclId]
        $dMonad_a1ROP
          = Control.Monad.Trans.Reader.$fMonadReaderT
              @ (NoLoggingT (R.ResourceT IO)) @ backend_a1ROE $dMonad_a1RT6 } in
      case ghc-prim-0.5.1.1:GHC.Types.HEq_sc
             @ *
             @ *
             @ (BaseBackend backend_a1ROE)
             @ SqlBackend
             (Data.Type.Equality.$p1~
                @ *
                @ (BaseBackend backend_a1ROE)
                @ SqlBackend
                (ghc-prim-0.5.1.1:GHC.Classes.$p2(%,%)
                   @ (IsPersistBackend backend_a1ROE)
                   @ ((BaseBackend backend_a1ROE :: *) ~ (SqlBackend :: *))
                   $d(%,%)_a1ROH))
      of cobox_a1RSZ
      { __DEFAULT ->
      \ (act_a1RMc :: ReaderT backend_a1ROE DBM a_a1ROF) ->
        $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
          @ (ReaderT backend_a1ROE DBM a_a1ROF)
          @ (IO a_a1ROF)
          (runDB
             @ backend_a1ROE
             @ a_a1ROF
             (($d(%,%)_a1ROH
               `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                          <IsPersistBackend backend>_N ((~) <*>_N cobox <SqlBackend>_N)_N)_R
                       :: ((IsPersistBackend backend_a1ROE,
                            (BaseBackend backend_a1ROE :: *)
                            ~
                            (SqlBackend :: *)) :: Constraint)
                          ~R#
                          ((IsPersistBackend backend_a1ROE,
                            (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)))
              `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                         <IsPersistBackend backend>_N
                         ((~) <*>_N (Sym cobox) <SqlBackend>_N)_N)_R
                      :: ((IsPersistBackend backend_a1ROE,
                           (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                         ~R#
                         ((IsPersistBackend backend_a1ROE,
                           (BaseBackend backend_a1ROE :: *)
                           ~
                           (SqlBackend :: *)) :: Constraint))))
          (>>
             @ (ReaderT backend_a1ROE DBM)
             $dMonad_a1ROP
             @ ()
             @ a_a1ROF
             (withReaderT
                @ *
                @ backend_a1ROE
                @ SqlBackend
                @ DBM
                @ ()
                (projectBackend
                   @ SqlBackend @ backend_a1ROE $dBackendCompatible_a1ROI)
                migrateIt)
             act_a1RMc)
      }

-- RHS size: {terms: 13, types: 40, coercions: 10, joins: 0/2}
runWrite :: forall a. ReaderT SqlWriteBackend DBM a -> IO a
[LclIdX]
runWrite
  = \ (@ a_a1RP1) ->
      let {
        $d~_a1RTb :: (SqlBackend :: *) ~ (SqlBackend :: *)
        [LclId]
        $d~_a1RTb
          = Data.Type.Equality.$f~kab
              @ *
              @ SqlBackend
              @ SqlBackend
              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                 @ *
                 @ *
                 @ SqlBackend
                 @ SqlBackend
                 @~ (<SqlBackend>_N
                     :: (SqlBackend :: *)
                        ghc-prim-0.5.1.1:GHC.Prim.~#
                        (SqlBackend :: *))) } in
      let {
        $d(%,%)_a1RT9
          :: (IsPersistBackend SqlWriteBackend,
              (SqlBackend :: *) ~ (SqlBackend :: *))
        [LclId]
        $d(%,%)_a1RT9
          = (Database.Persist.Sql.Types.Internal.$fIsPersistBackendSqlWriteBackend,
             $d~_a1RTb) } in
      \ (act_a1RMb :: ReaderT SqlWriteBackend DBM a_a1RP1) ->
        run_worker
          @ SqlWriteBackend
          @ a_a1RP1
          ($d(%,%)_a1RT9
           `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                      <IsPersistBackend SqlWriteBackend>_N
                      ((~)
                         <*>_N
                         (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlWriteBackend[0]))
                         <SqlBackend>_N)_N)_R
                   :: ((IsPersistBackend SqlWriteBackend,
                        (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                      ~R#
                      ((IsPersistBackend SqlWriteBackend,
                        (BaseBackend SqlWriteBackend :: *)
                        ~
                        (SqlBackend :: *)) :: Constraint)))
          persistent-2.8.1:Database.Persist.Sql.Orphan.PersistStore.$fBackendCompatibleSqlBackendSqlWriteBackend
          act_a1RMb

-- RHS size: {terms: 13, types: 40, coercions: 10, joins: 0/2}
runRead :: forall a. ReaderT SqlReadBackend DBM a -> IO a
[LclIdX]
runRead
  = \ (@ a_a1RP8) ->
      let {
        $d~_a1RTg :: (SqlBackend :: *) ~ (SqlBackend :: *)
        [LclId]
        $d~_a1RTg
          = Data.Type.Equality.$f~kab
              @ *
              @ SqlBackend
              @ SqlBackend
              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                 @ *
                 @ *
                 @ SqlBackend
                 @ SqlBackend
                 @~ (<SqlBackend>_N
                     :: (SqlBackend :: *)
                        ghc-prim-0.5.1.1:GHC.Prim.~#
                        (SqlBackend :: *))) } in
      let {
        $d(%,%)_a1RTe
          :: (IsPersistBackend SqlReadBackend,
              (SqlBackend :: *) ~ (SqlBackend :: *))
        [LclId]
        $d(%,%)_a1RTe
          = (Database.Persist.Sql.Types.Internal.$fIsPersistBackendSqlReadBackend,
             $d~_a1RTg) } in
      \ (act_a1RMa :: ReaderT SqlReadBackend DBM a_a1RP8) ->
        run_worker
          @ SqlReadBackend
          @ a_a1RP8
          ($d(%,%)_a1RTe
           `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                      <IsPersistBackend SqlReadBackend>_N
                      ((~)
                         <*>_N
                         (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlReadBackend[0]))
                         <SqlBackend>_N)_N)_R
                   :: ((IsPersistBackend SqlReadBackend,
                        (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                      ~R#
                      ((IsPersistBackend SqlReadBackend,
                        (BaseBackend SqlReadBackend :: *)
                        ~
                        (SqlBackend :: *)) :: Constraint)))
          persistent-2.8.1:Database.Persist.Sql.Orphan.PersistStore.$fBackendCompatibleSqlBackendSqlReadBackend
          act_a1RMa

-- RHS size: {terms: 175, types: 427, coercions: 58, joins: 0/3}
testWriteFailsInRead :: Spec
[LclIdX]
testWriteFailsInRead
  = >>
      @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM ())
      (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.$fMonadSpecM @ ())
      @ ()
      @ ()
      ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
         @ HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
         @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ())
         ((it
             @ HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
             ((GHC.Stack.Types.pushCallStack
                 (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "it"#,
                  GHC.Stack.Types.SrcLoc
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "main"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "ReadWrite.ShouldNotTypeCheck"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs"#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 41#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 3#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 41#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 46#))
                 ((GHC.Stack.Types.emptyCallStack
                   `cast` (Sym
                             (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                           :: (GHC.Stack.Types.CallStack :: *)
                              ~R#
                              ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
                  `cast` (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                            <"callStack">_N <GHC.Stack.Types.CallStack>_N
                          :: ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)
                             ~R#
                             (GHC.Stack.Types.CallStack :: *))))
              `cast` (Sym
                        (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                      :: (GHC.Stack.Types.CallStack :: *)
                         ~R#
                         ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
             hspec-core-2.4.4:Test.Hspec.Core.Example.$fExampleIO
             (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                "fails when we insert under a `RunRead`"#))
          `cast` (<HUnit-1.6.0.0:Test.HUnit.Lang.Assertion>_R
                  -> (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                        (hspec-core-2.4.4:Test.Hspec.Core.Example.D:R:ArgIO[0]) <()>_N)_R
                  :: ((HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                            (Arg Expectation) ()) :: *)
                     ~R#
                     ((HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ()) :: *)))
         ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
            @ ((() :: *) ~ (() :: *) => ())
            @ HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
            (shouldNotTypecheckWith
               @ () @ String Control.DeepSeq.$fNFData() readCannotInsert)
            (\ _ [Occ=Dead] ->
               $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                 @ (IO ())
                 @ ()
                 (unsafePerformIO @ ())
                 ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                    @ (ReaderT SqlReadBackend DBM ())
                    @ (IO ())
                    (runRead @ ())
                    ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                       @ (ReaderT SqlReadBackend DBM (Key Person))
                       @ (ReaderT SqlReadBackend DBM ())
                       (void
                          @ (ReaderT SqlReadBackend DBM)
                          @ (Key Person)
                          (Control.Monad.Trans.Reader.$fFunctorReaderT
                             @ (NoLoggingT (R.ResourceT IO))
                             @ SqlReadBackend
                             (Control.Monad.Logger.$fFunctorNoLoggingT
                                @ (R.ResourceT IO)
                                (Control.Monad.Trans.Resource.Internal.$fFunctorResourceT
                                   @ IO GHC.Base.$fFunctorIO))))
                       (insert
                          @ SqlReadBackend
                          (Control.Exception.Base.typeError
                             @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                             @ (PersistStoreWrite SqlReadBackend)
                             "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:43:14: error:\n\
                             \    \\226\\128\\162 Could not deduce (PersistStoreWrite SqlReadBackend)\n\
                             \        arising from a use of \\226\\128\\152insert\\226\\128\\153\n\
                             \      from the context: () ~ ()\n\
                             \        bound by a type expected by the context:\n\
                             \                   () ~ () => ()\n\
                             \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(42,5)-(43,22)\n\
                             \    \\226\\128\\162 In the second argument of \\226\\128\\152($)\\226\\128\\153, namely \\226\\128\\152insert p1\\226\\128\\153\n\
                             \      In a stmt of a 'do' block: void $ insert p1\n\
                             \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely \\226\\128\\152do void $ insert p1\\226\\128\\153\n\
                             \(deferred type error)"#)
                          @ DBM
                          @ Person
                          (Control.Monad.Logger.$fMonadIONoLoggingT
                             @ (R.ResourceT IO)
                             (Control.Monad.Trans.Resource.Internal.$fMonadIOResourceT
                                @ IO Control.Monad.IO.Class.$fMonadIOIO))
                          ((Common.Test.$fPersistEntityPerson,
                            Data.Type.Equality.$f~kab
                              @ *
                              @ SqlBackend
                              @ SqlBackend
                              (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                 @ *
                                 @ *
                                 @ SqlBackend
                                 @ SqlBackend
                                 @~ (<SqlBackend>_N
                                     :: (SqlBackend :: *)
                                        ghc-prim-0.5.1.1:GHC.Prim.~#
                                        (SqlBackend :: *))))
                           `cast` ((ghc-prim-0.5.1.1:GHC.Classes.(%,%)
                                      <PersistEntity Person>_N
                                      ((~)
                                         <*>_N
                                         (Sym (Common.Test.D:R:PersistEntityBackendPerson[0]))
                                         (Sym (Database.Persist.Sql.Types.Internal.D:R:BaseBackendSqlReadBackend[0])))_N)_R
                                   :: ((PersistEntity Person,
                                        (SqlBackend :: *) ~ (SqlBackend :: *)) :: Constraint)
                                      ~R#
                                      ((PersistEntity Person,
                                        (PersistEntityBackend Person :: *)
                                        ~
                                        (BaseBackend SqlReadBackend :: *)) :: Constraint)))
                          p1))))))
      ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
         @ HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
         @ (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ())
         ((it
             @ HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
             ((GHC.Stack.Types.pushCallStack
                 (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "it"#,
                  GHC.Stack.Types.SrcLoc
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString# "main"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "ReadWrite.ShouldNotTypeCheck"#)
                    (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                       "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs"#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 53#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 3#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 53#)
                    (ghc-prim-0.5.1.1:GHC.Types.I# 46#))
                 ((GHC.Stack.Types.emptyCallStack
                   `cast` (Sym
                             (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                           :: (GHC.Stack.Types.CallStack :: *)
                              ~R#
                              ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
                  `cast` (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                            <"callStack">_N <GHC.Stack.Types.CallStack>_N
                          :: ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)
                             ~R#
                             (GHC.Stack.Types.CallStack :: *))))
              `cast` (Sym
                        (ghc-prim-0.5.1.1:GHC.Classes.N:IP[0]
                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                      :: (GHC.Stack.Types.CallStack :: *)
                         ~R#
                         ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
             hspec-core-2.4.4:Test.Hspec.Core.Example.$fExampleIO
             (ghc-prim-0.5.1.1:GHC.CString.unpackCString#
                "fails when we update under a `RunRead`"#))
          `cast` (<HUnit-1.6.0.0:Test.HUnit.Lang.Assertion>_R
                  -> (hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                        (hspec-core-2.4.4:Test.Hspec.Core.Example.D:R:ArgIO[0]) <()>_N)_R
                  :: ((HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM
                            (Arg Expectation) ()) :: *)
                     ~R#
                     ((HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
                       -> hspec-core-2.4.4:Test.Hspec.Core.Spec.Monad.SpecM () ()) :: *)))
         ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
            @ ((() :: *) ~ (() :: *) => ())
            @ HUnit-1.6.0.0:Test.HUnit.Lang.Assertion
            (shouldNotTypecheckWith
               @ () @ String Control.DeepSeq.$fNFData() readCannotUpdate)
            (\ _ [Occ=Dead] ->
               $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                 @ (IO ())
                 @ ()
                 (unsafePerformIO @ ())
                 ($ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                    @ (ReaderT SqlReadBackend DBM ())
                    @ (IO ())
                    (runRead @ ())
                    (deepseq
                       @ (ReaderT
                            ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ())
                       @ (ReaderT SqlReadBackend DBM ())
                       (Control.Exception.Base.typeError
                          @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                          @ (NFData
                               (ReaderT
                                  ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ()))
                          "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:62:9: error:\n\
                          \    \\226\\128\\162 Could not deduce (NFData (ReaderT backend0 m0 ()))\n\
                          \        arising from a use of \\226\\128\\152deepseq\\226\\128\\153\n\
                          \      from the context: () ~ ()\n\
                          \        bound by a type expected by the context:\n\
                          \                   () ~ () => ()\n\
                          \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                          \      The type variables \\226\\128\\152backend0\\226\\128\\153, \\226\\128\\152m0\\226\\128\\153 are ambiguous\n\
                          \      Relevant bindings include\n\
                          \        q :: ReaderT backend0 m0 ()\n\
                          \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                          \    \\226\\128\\162 In a stmt of a 'do' block: deepseq q (return ())\n\
                          \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                          \        \\226\\128\\152do let q = update $ ...\n\
                          \            deepseq q (return ())\\226\\128\\153\n\
                          \      In a stmt of a 'do' block:\n\
                          \        runRead\n\
                          \          $ do let q = update $ ...\n\
                          \               deepseq q (return ())\n\
                          \(deferred type error)"#)
                       (let {
                          $dBackendCompatible_a1RS9
                            :: BackendCompatible SqlBackend ghc-prim-0.5.1.1:GHC.Types.Any
                          [LclId]
                          $dBackendCompatible_a1RS9
                            = Control.Exception.Base.typeError
                                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                @ (BackendCompatible SqlBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                \      from the context: () ~ ()\n\
                                \        bound by a type expected by the context:\n\
                                \                   () ~ () => ()\n\
                                \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                \      Relevant bindings include\n\
                                \        q :: ReaderT backend0 m0 ()\n\
                                \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                \      These potential instances exist:\n\
                                \        instance PersistQueryWrite SqlBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \        instance PersistQueryWrite SqlWriteBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \    \\226\\128\\162 In the expression:\n\
                                \        update\n\
                                \          $ \\ person\n\
                                \              -> do set person [...]\n\
                                \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                \          q = update\n\
                                \                $ \\ person\n\
                                \                    -> do set person ...\n\
                                \                          ....\n\
                                \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                \        \\226\\128\\152do let q = update $ ...\n\
                                \            deepseq q (return ())\\226\\128\\153\n\
                                \(deferred type error)"# } in
                        case Control.Exception.Base.typeError
                               @ ('ghc-prim-0.5.1.1:GHC.Types.TupleRep '[])
                               @ ((BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any :: *)
                                  ghc-prim-0.5.1.1:GHC.Prim.~#
                                  (SqlBackend :: *))
                               "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                               \    \\226\\128\\162 Couldn't match type \\226\\128\\152BaseBackend backend0\\226\\128\\153 with \\226\\128\\152SqlBackend\\226\\128\\153\n\
                               \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                               \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                               \    \\226\\128\\162 In the expression:\n\
                               \        update\n\
                               \          $ \\ person\n\
                               \              -> do set person [...]\n\
                               \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                               \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                               \          q = update\n\
                               \                $ \\ person\n\
                               \                    -> do set person ...\n\
                               \                          ....\n\
                               \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                               \        \\226\\128\\152do let q = update $ ...\n\
                               \            deepseq q (return ())\\226\\128\\153\n\
                               \    \\226\\128\\162 Relevant bindings include\n\
                               \        q :: ReaderT backend0 m0 ()\n\
                               \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                               \(deferred type error)"#
                        of cobox_a1RU0
                        { __DEFAULT ->
                        let {
                          $d~_a1RRF :: (Key Person :: *) ~ (Key Person :: *)
                          [LclId]
                          $d~_a1RRF
                            = Data.Type.Equality.$f~kab
                                @ *
                                @ (Key Person)
                                @ (Key Person)
                                (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                   @ *
                                   @ *
                                   @ (Key Person)
                                   @ (Key Person)
                                   @~ (<Key Person>_N
                                       :: (Key Person :: *)
                                          ghc-prim-0.5.1.1:GHC.Prim.~#
                                          (Key Person :: *))) } in
                        let {
                          $d~_a1RRd :: ([Char] :: *) ~ (String :: *)
                          [LclId]
                          $d~_a1RRd
                            = Data.Type.Equality.$f~kab
                                @ *
                                @ [Char]
                                @ [Char]
                                (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                   @ *
                                   @ *
                                   @ [Char]
                                   @ [Char]
                                   @~ (<[Char]>_N
                                       :: ([Char] :: *)
                                          ghc-prim-0.5.1.1:GHC.Prim.~#
                                          ([Char] :: *))) } in
                        $ @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                          @ (SqlExpr (Entity Person) -> SqlQuery ())
                          @ (ReaderT
                               ghc-prim-0.5.1.1:GHC.Types.Any ghc-prim-0.5.1.1:GHC.Types.Any ())
                          (update
                             @ Person
                             @ ghc-prim-0.5.1.1:GHC.Types.Any
                             @ ghc-prim-0.5.1.1:GHC.Types.Any
                             ((Data.Type.Equality.$f~kab
                                 @ *
                                 @ SqlBackend
                                 @ (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                                 (ghc-prim-0.5.1.1:GHC.Types.Eq#
                                    @ *
                                    @ *
                                    @ SqlBackend
                                    @ (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any)
                                    @~ (Sym cobox_a1RU0
                                        :: (SqlBackend :: *)
                                           ghc-prim-0.5.1.1:GHC.Prim.~#
                                           (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any :: *))))
                              `cast` (((~)
                                         <*>_N
                                         (Sym (Common.Test.D:R:PersistEntityBackendPerson[0]))
                                         <BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any>_N)_R
                                      :: ((SqlBackend :: *)
                                          ~
                                          (BaseBackend
                                             ghc-prim-0.5.1.1:GHC.Types.Any :: *) :: Constraint)
                                         ~R#
                                         ((PersistEntityBackend Person :: *)
                                          ~
                                          (BaseBackend
                                             ghc-prim-0.5.1.1:GHC.Types.Any :: *) :: Constraint)))
                             Common.Test.$fPersistEntityPerson
                             (($dBackendCompatible_a1RS9,
                               Control.Exception.Base.typeError
                                 @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                 @ (PersistQueryRead ghc-prim-0.5.1.1:GHC.Types.Any)
                                 "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                 \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                 \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                 \      from the context: () ~ ()\n\
                                 \        bound by a type expected by the context:\n\
                                 \                   () ~ () => ()\n\
                                 \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                 \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                 \      Relevant bindings include\n\
                                 \        q :: ReaderT backend0 m0 ()\n\
                                 \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                 \      These potential instances exist:\n\
                                 \        instance PersistQueryWrite SqlBackend\n\
                                 \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                 \        instance PersistQueryWrite SqlWriteBackend\n\
                                 \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                 \    \\226\\128\\162 In the expression:\n\
                                 \        update\n\
                                 \          $ \\ person\n\
                                 \              -> do set person [...]\n\
                                 \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                 \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                 \          q = update\n\
                                 \                $ \\ person\n\
                                 \                    -> do set person ...\n\
                                 \                          ....\n\
                                 \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                 \        \\226\\128\\152do let q = update $ ...\n\
                                 \            deepseq q (return ())\\226\\128\\153\n\
                                 \(deferred type error)"#,
                               Control.Exception.Base.typeError
                                 @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                 @ (PersistStoreRead ghc-prim-0.5.1.1:GHC.Types.Any)
                                 "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                 \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                 \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                 \      from the context: () ~ ()\n\
                                 \        bound by a type expected by the context:\n\
                                 \                   () ~ () => ()\n\
                                 \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                 \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                 \      Relevant bindings include\n\
                                 \        q :: ReaderT backend0 m0 ()\n\
                                 \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                 \      These potential instances exist:\n\
                                 \        instance PersistQueryWrite SqlBackend\n\
                                 \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                 \        instance PersistQueryWrite SqlWriteBackend\n\
                                 \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                 \    \\226\\128\\162 In the expression:\n\
                                 \        update\n\
                                 \          $ \\ person\n\
                                 \              -> do set person [...]\n\
                                 \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                 \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                 \          q = update\n\
                                 \                $ \\ person\n\
                                 \                    -> do set person ...\n\
                                 \                          ....\n\
                                 \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                 \        \\226\\128\\152do let q = update $ ...\n\
                                 \            deepseq q (return ())\\226\\128\\153\n\
                                 \(deferred type error)"#,
                               Control.Exception.Base.typeError
                                 @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                 @ (PersistUniqueRead ghc-prim-0.5.1.1:GHC.Types.Any)
                                 "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                 \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                 \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                 \      from the context: () ~ ()\n\
                                 \        bound by a type expected by the context:\n\
                                 \                   () ~ () => ()\n\
                                 \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                 \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                 \      Relevant bindings include\n\
                                 \        q :: ReaderT backend0 m0 ()\n\
                                 \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                 \      These potential instances exist:\n\
                                 \        instance PersistQueryWrite SqlBackend\n\
                                 \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                 \        instance PersistQueryWrite SqlWriteBackend\n\
                                 \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                 \    \\226\\128\\162 In the expression:\n\
                                 \        update\n\
                                 \          $ \\ person\n\
                                 \              -> do set person [...]\n\
                                 \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                 \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                 \          q = update\n\
                                 \                $ \\ person\n\
                                 \                    -> do set person ...\n\
                                 \                          ....\n\
                                 \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                 \        \\226\\128\\152do let q = update $ ...\n\
                                 \            deepseq q (return ())\\226\\128\\153\n\
                                 \(deferred type error)"#),
                              Control.Exception.Base.typeError
                                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                @ (PersistQueryWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                \      from the context: () ~ ()\n\
                                \        bound by a type expected by the context:\n\
                                \                   () ~ () => ()\n\
                                \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                \      Relevant bindings include\n\
                                \        q :: ReaderT backend0 m0 ()\n\
                                \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                \      These potential instances exist:\n\
                                \        instance PersistQueryWrite SqlBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \        instance PersistQueryWrite SqlWriteBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \    \\226\\128\\162 In the expression:\n\
                                \        update\n\
                                \          $ \\ person\n\
                                \              -> do set person [...]\n\
                                \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                \          q = update\n\
                                \                $ \\ person\n\
                                \                    -> do set person ...\n\
                                \                          ....\n\
                                \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                \        \\226\\128\\152do let q = update $ ...\n\
                                \            deepseq q (return ())\\226\\128\\153\n\
                                \(deferred type error)"#,
                              Control.Exception.Base.typeError
                                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                @ (PersistStoreWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                \      from the context: () ~ ()\n\
                                \        bound by a type expected by the context:\n\
                                \                   () ~ () => ()\n\
                                \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                \      Relevant bindings include\n\
                                \        q :: ReaderT backend0 m0 ()\n\
                                \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                \      These potential instances exist:\n\
                                \        instance PersistQueryWrite SqlBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \        instance PersistQueryWrite SqlWriteBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \    \\226\\128\\162 In the expression:\n\
                                \        update\n\
                                \          $ \\ person\n\
                                \              -> do set person [...]\n\
                                \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                \          q = update\n\
                                \                $ \\ person\n\
                                \                    -> do set person ...\n\
                                \                          ....\n\
                                \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                \        \\226\\128\\152do let q = update $ ...\n\
                                \            deepseq q (return ())\\226\\128\\153\n\
                                \(deferred type error)"#,
                              Control.Exception.Base.typeError
                                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                @ (PersistUniqueWrite ghc-prim-0.5.1.1:GHC.Types.Any)
                                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                \      from the context: () ~ ()\n\
                                \        bound by a type expected by the context:\n\
                                \                   () ~ () => ()\n\
                                \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                \      Relevant bindings include\n\
                                \        q :: ReaderT backend0 m0 ()\n\
                                \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                \      These potential instances exist:\n\
                                \        instance PersistQueryWrite SqlBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \        instance PersistQueryWrite SqlWriteBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \    \\226\\128\\162 In the expression:\n\
                                \        update\n\
                                \          $ \\ person\n\
                                \              -> do set person [...]\n\
                                \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                \          q = update\n\
                                \                $ \\ person\n\
                                \                    -> do set person ...\n\
                                \                          ....\n\
                                \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                \        \\226\\128\\152do let q = update $ ...\n\
                                \            deepseq q (return ())\\226\\128\\153\n\
                                \(deferred type error)"#)
                             $dBackendCompatible_a1RS9
                             (Control.Exception.Base.typeError
                                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                @ (BackendCompatible
                                     SqlBackend (BaseBackend ghc-prim-0.5.1.1:GHC.Types.Any))
                                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                \      from the context: () ~ ()\n\
                                \        bound by a type expected by the context:\n\
                                \                   () ~ () => ()\n\
                                \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                \      Relevant bindings include\n\
                                \        q :: ReaderT backend0 m0 ()\n\
                                \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                \      These potential instances exist:\n\
                                \        instance PersistQueryWrite SqlBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \        instance PersistQueryWrite SqlWriteBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \    \\226\\128\\162 In the expression:\n\
                                \        update\n\
                                \          $ \\ person\n\
                                \              -> do set person [...]\n\
                                \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                \          q = update\n\
                                \                $ \\ person\n\
                                \                    -> do set person ...\n\
                                \                          ....\n\
                                \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                \        \\226\\128\\152do let q = update $ ...\n\
                                \            deepseq q (return ())\\226\\128\\153\n\
                                \(deferred type error)"#)
                             Common.Test.$fPersistEntityPerson
                             (Control.Exception.Base.typeError
                                @ 'ghc-prim-0.5.1.1:GHC.Types.LiftedRep
                                @ (MonadIO ghc-prim-0.5.1.1:GHC.Types.Any)
                                "/home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:17: error:\n\
                                \    \\226\\128\\162 Could not deduce (PersistQueryWrite backend0)\n\
                                \        arising from a use of \\226\\128\\152update\\226\\128\\153\n\
                                \      from the context: () ~ ()\n\
                                \        bound by a type expected by the context:\n\
                                \                   () ~ () => ()\n\
                                \        at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:(54,5)-(62,29)\n\
                                \      The type variable \\226\\128\\152backend0\\226\\128\\153 is ambiguous\n\
                                \      Relevant bindings include\n\
                                \        q :: ReaderT backend0 m0 ()\n\
                                \          (bound at /home/matt/Projects/esqueleto/test/ReadWrite/ShouldNotTypeCheck.hs:59:13)\n\
                                \      These potential instances exist:\n\
                                \        instance PersistQueryWrite SqlBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \        instance PersistQueryWrite SqlWriteBackend\n\
                                \          -- Defined in \\226\\128\\152persistent-2.8.1:Database.Persist.Sql.Orphan.PersistQuery\\226\\128\\153\n\
                                \    \\226\\128\\162 In the expression:\n\
                                \        update\n\
                                \          $ \\ person\n\
                                \              -> do set person [...]\n\
                                \                    where_ (person ^. PersonId ==. val (toSqlKey 1))\n\
                                \      In an equation for \\226\\128\\152q\\226\\128\\153:\n\
                                \          q = update\n\
                                \                $ \\ person\n\
                                \                    -> do set person ...\n\
                                \                          ....\n\
                                \      In the second argument of \\226\\128\\152($)\\226\\128\\153, namely\n\
                                \        \\226\\128\\152do let q = update $ ...\n\
                                \            deepseq q (return ())\\226\\128\\153\n\
                                \(deferred type error)"#))
                          (\ (person_a1RM9 :: SqlExpr (Entity Person)) ->
                             >>
                               @ SqlQuery
                               Database.Esqueleto.Internal.Sql.$fMonadSqlQuery
                               @ ()
                               @ ()
                               (set
                                  @ SqlQuery
                                  @ SqlExpr
                                  @ SqlBackend
                                  Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                  @ Person
                                  Common.Test.$fPersistEntityPerson
                                  person_a1RM9
                                  (ghc-prim-0.5.1.1:GHC.Types.:
                                     @ (SqlExpr
                                          (Database.Esqueleto.Internal.Language.Update Person))
                                     (=.
                                        @ SqlQuery
                                        @ SqlExpr
                                        @ SqlBackend
                                        Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                        @ Person
                                        @ [Char]
                                        Common.Test.$fPersistEntityPerson
                                        persistent-2.8.1:Database.Persist.Class.PersistField.$fPersistField[]0
                                        (Common.Test.$WPersonName @ [Char] $d~_a1RRd)
                                        (val
                                           @ SqlQuery
                                           @ SqlExpr
                                           @ SqlBackend
                                           Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                           @ [Char]
                                           persistent-2.8.1:Database.Persist.Class.PersistField.$fPersistField[]0
                                           (ghc-prim-0.5.1.1:GHC.CString.unpackCStringUtf8#
                                              "Jo\\195\\163o"#)))
                                     (ghc-prim-0.5.1.1:GHC.Types.[]
                                        @ (SqlExpr
                                             (Database.Esqueleto.Internal.Language.Update
                                                Person)))))
                               (where_
                                  @ SqlQuery
                                  @ SqlExpr
                                  @ SqlBackend
                                  Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                  (==.
                                     @ SqlQuery
                                     @ SqlExpr
                                     @ SqlBackend
                                     Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                     @ (Key Person)
                                     Common.Test.$fPersistFieldKey12
                                     (^.
                                        @ SqlQuery
                                        @ SqlExpr
                                        @ SqlBackend
                                        Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                        @ Person
                                        @ (Key Person)
                                        Common.Test.$fPersistEntityPerson
                                        Common.Test.$fPersistFieldKey12
                                        person_a1RM9
                                        (Common.Test.$WPersonId @ (Key Person) $d~_a1RRF))
                                     (val
                                        @ SqlQuery
                                        @ SqlExpr
                                        @ SqlBackend
                                        Database.Esqueleto.Internal.Sql.$fEsqueletoSqlQuerySqlExprSqlBackend
                                        @ (Key Person)
                                        Common.Test.$fPersistFieldKey12
                                        (toSqlKey
                                           @ Person
                                           Common.Test.$fToBackendKeySqlBackendPerson
                                           (fromInteger @ GHC.Int.Int64 GHC.Int.$fNumInt64 1))))))
                        })
                       (return
                          @ (ReaderT SqlReadBackend DBM)
                          (Control.Monad.Trans.Reader.$fMonadReaderT
                             @ (NoLoggingT (R.ResourceT IO))
                             @ SqlReadBackend
                             (Control.Monad.Logger.$fMonadNoLoggingT
                                @ (R.ResourceT IO)
                                (Control.Monad.Trans.Resource.Internal.$fMonadResourceT
                                   @ IO GHC.Base.$fMonadIO)))
                          @ ()
                          ghc-prim-0.5.1.1:GHC.Tuple.()))))))

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
ReadWrite.ShouldNotTypeCheck.$trModule
  :: ghc-prim-0.5.1.1:GHC.Types.Module
[LclIdX]
ReadWrite.ShouldNotTypeCheck.$trModule
  = ghc-prim-0.5.1.1:GHC.Types.Module
      (ghc-prim-0.5.1.1:GHC.Types.TrNameS "main"#)
      (ghc-prim-0.5.1.1:GHC.Types.TrNameS
         "ReadWrite.ShouldNotTypeCheck"#)


